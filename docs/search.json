[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "For those looking to get a head start on the course material, you can look over the following two textbooks, which cover the course topics in the same general order that we will cover them (although with very different approaches: the target audience for these tends to be software engineers, who have slightly different needs from us data scientists!)\n\nGoodrich, Michael T., Roberto Tamassia, and Michael H. Goldwasser. 2013. Data Structures and Algorithms in Python. [PDF] [EPUB]\nLee, Kent D., and Steve Hubbard. 2015. Data Structures and Algorithms with Python. [PDF] [EPUB]\n\nFor much of the course we’ll be focusing on a “standard” collection of algorithms that all computer scientists (including data scientists!) should know; the most famous book collecting all of these algorithms into one place is known as “CLRS”, which is an abbreviation for the family names of the four authors (Cormen, Leiserson, Rivest, and Stein). The authors just released a Fourth Edition of the book in 2022, but the Third Edition is much easier to obtain, and honestly any edition should be fine for the level of depth we’ll be going into:\n\nCormen, Thomas H., Charles E. Leiserson, Ronald R. Rivest, and Clifford Stein. 2022. Introduction to Algorithms, Fourth Edition. [PDF] [EPUB]",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#textbooks",
    "href": "resources.html#textbooks",
    "title": "Resources",
    "section": "",
    "text": "For those looking to get a head start on the course material, you can look over the following two textbooks, which cover the course topics in the same general order that we will cover them (although with very different approaches: the target audience for these tends to be software engineers, who have slightly different needs from us data scientists!)\n\nGoodrich, Michael T., Roberto Tamassia, and Michael H. Goldwasser. 2013. Data Structures and Algorithms in Python. [PDF] [EPUB]\nLee, Kent D., and Steve Hubbard. 2015. Data Structures and Algorithms with Python. [PDF] [EPUB]\n\nFor much of the course we’ll be focusing on a “standard” collection of algorithms that all computer scientists (including data scientists!) should know; the most famous book collecting all of these algorithms into one place is known as “CLRS”, which is an abbreviation for the family names of the four authors (Cormen, Leiserson, Rivest, and Stein). The authors just released a Fourth Edition of the book in 2022, but the Third Edition is much easier to obtain, and honestly any edition should be fine for the level of depth we’ll be going into:\n\nCormen, Thomas H., Charles E. Leiserson, Ronald R. Rivest, and Clifford Stein. 2022. Introduction to Algorithms, Fourth Edition. [PDF] [EPUB]",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#online-resources",
    "href": "resources.html#online-resources",
    "title": "Resources",
    "section": "Online Resources",
    "text": "Online Resources\nIn terms of resources specifically aimed at data scientists, Datacamp has the following sequence of Python-based courses:\n\nIntroduction to Python for Data Science\nPython Data Science Toolbox (Part 1)\nPython Data Science Toolbox (Part 2)\nObject-Oriented Programming in Python",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "w01/slides.html#before-and-after",
    "href": "w01/slides.html#before-and-after",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Before and After",
    "text": "Before and After\n\n\n\n\n\n\nPython before taking DSAN 5500\n\n\n\n\n\n\n\nPython after taking DSAN 5500"
  },
  {
    "objectID": "w01/slides.html#developing-a-comparative-understanding",
    "href": "w01/slides.html#developing-a-comparative-understanding",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Developing a Comparative Understanding",
    "text": "Developing a Comparative Understanding\n\n\n\n\n\n\n“We hardly know ourselves, if we know nobody else”\n\n\n–(Blue Scholars, “Sagaba”)\n\n\n\n\n\n\nThe course focuses on Python, but part of understanding Python is understanding how Python does things differently from other languages!\nJust as C was “overtaken” by Java, then Java was “overtaken” by Python, Python will someday be overtaken"
  },
  {
    "objectID": "w01/slides.html#the-numbers",
    "href": "w01/slides.html#the-numbers",
    "title": "Week 1: Course Intro and Motivation",
    "section": "The Numbers",
    "text": "The Numbers\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nlang_df = pd.read_csv(\"assets/gh_issues.csv\")\n# The data for 2022 is essentially useless\nlang_df = lang_df[lang_df['year'] &lt;= 2021].copy()\nlang_df['time'] = lang_df['year'].astype(str) + \"_\" + lang_df['quarter'].astype(str)\nlang_df['prop'] = lang_df['count'] / lang_df.groupby('time')['count'].transform('sum')\nlang_df.head()\n#sns.lineplot(data=lang_df, x='year', y='count', color='name')\n# Keep only most popular languages\nkeep_langs = ['Python','JavaScript','C','C++','C#','Java','Ruby']\npop_df = lang_df[lang_df['name'].isin(keep_langs)].copy()\nfig = px.line(pop_df,\n  x='time', y='prop', color='name',\n  template='simple_white', title='Programming Language Popularity Since 2012',\n  labels = {\n    'time': 'Year',\n    'prop': 'Proportion of GitHub Issues'\n  }\n)\nfig.update_layout(\n  xaxis = dict(\n    tickmode = 'array',\n    tickvals = [f\"{year}_1\" for year in range(2012,2022)],\n    ticktext = [f\"{year}\" for year in range(2012,2022)]\n  )\n)\nfig.show()"
  },
  {
    "objectID": "w01/slides.html#research-particular-subfields",
    "href": "w01/slides.html#research-particular-subfields",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Research Particular Subfields!",
    "text": "Research Particular Subfields!\n\nFor example, if you’re interested in pursuing Economics, you’ll want to learn Stata\nPhysics? You may want to learn MATLAB\nFor pure mathematics: Julia / Mathematica\nStatistics, sociology, psychology, political science: R\nWeb development: JavaScript / TypeScript\nThe holy grail: you’re comfortable with Python but can also think in general, language-agnostic terms about algorithmic and data-structural efficiency!"
  },
  {
    "objectID": "w01/slides.html#avoid-analysis-paralysis",
    "href": "w01/slides.html#avoid-analysis-paralysis",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Avoid Analysis Paralysis",
    "text": "Avoid Analysis Paralysis\n\n(Easier said than done, admittedly…)\n\n\nImage source: XKCD"
  },
  {
    "objectID": "w01/slides.html#tie-yourself-to-the-mast",
    "href": "w01/slides.html#tie-yourself-to-the-mast",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Tie Yourself to the Mast",
    "text": "Tie Yourself to the Mast\n\nThe exhausted 3am version of you will thank present you for writing useful comments, exceptions/errors, and type hints!\n\n\nJohn William Waterhouse, Public domain, via Wikimedia Commons"
  },
  {
    "objectID": "w01/slides.html#types-of-languages",
    "href": "w01/slides.html#types-of-languages",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Types of Languages",
    "text": "Types of Languages\n\nCompiled\nInterpreted"
  },
  {
    "objectID": "w01/slides.html#primitive-types",
    "href": "w01/slides.html#primitive-types",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Primitive Types",
    "text": "Primitive Types\n\nBoolean (True or False)\nNumbers (Integers, Decimals)\nStrings\nNone"
  },
  {
    "objectID": "w01/slides.html#stack-and-heap",
    "href": "w01/slides.html#stack-and-heap",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Stack and Heap",
    "text": "Stack and Heap\nLet’s look at what happens, in the computer’s memory, when we run the following code:\n\n\n\n\nCode\nimport datetime\nimport pandas as pd\ncountry_df = pd.read_csv(\"assets/country_pop.csv\")\npop_col = country_df['pop']\nnum_rows = len(country_df)\nfilled = all(~pd.isna(country_df))\nalg_row = country_df.loc[country_df['name'] == \"Algeria\"]\nnum_cols = len(country_df.columns)\nusername = \"Jeff\"\ncur_date = datetime.datetime.now()\ni = 0\nj = None\nz = 314\ncountry_df\n\n\n\n\n\n\n\n\n\nname\npop\n\n\n\n\n0\nAlbania\n2.8\n\n\n1\nAlgeria\n44.2\n\n\n2\nAngola\n34.5"
  },
  {
    "objectID": "w01/slides.html#algorithmic-thinking",
    "href": "w01/slides.html#algorithmic-thinking",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Algorithmic Thinking",
    "text": "Algorithmic Thinking\n\nWhat are the inputs?\nWhat are the outputs?\nStandard cases vs. edge cases\nAdversarial development: brainstorm all of the ways an evil hacker might break your code!"
  },
  {
    "objectID": "w01/slides.html#example-finding-an-item-within-a-list",
    "href": "w01/slides.html#example-finding-an-item-within-a-list",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Example: Finding An Item Within A List",
    "text": "Example: Finding An Item Within A List\n\nSeems straightforward, right? Given a list l, and a value v, return the index of l which contains v\nCorner cases galore…\nWhat if l contains v more than once? What if it doesn’t contain v at all? What if l is None? What if v is None? What if l isn’t a list at all? What if v is itself a list?"
  },
  {
    "objectID": "w01/slides.html#sanity-preserving-tip",
    "href": "w01/slides.html#sanity-preserving-tip",
    "title": "Week 1: Course Intro and Motivation",
    "section": "#1 Sanity-Preserving Tip!",
    "text": "#1 Sanity-Preserving Tip!\n\n(For our purposes) the answer to “what is Python?” is: an executable file that runs .py files!\n\ne.g., we can run python mycode.py in Terminal/PowerShell\n\nEverything else: pip, Jupyter, Pandas, etc., is an add-on to this basic functionality!"
  },
  {
    "objectID": "w01/slides.html#code-blocks-via-indentation",
    "href": "w01/slides.html#code-blocks-via-indentation",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Code Blocks via Indentation",
    "text": "Code Blocks via Indentation\n\n\nCode\nfor i in range(5):\n    print(i)\n\n\n0\n1\n2\n3\n4\n\n\n\n\nCode\nfor i in range(5):\nprint(i)\n\n\nIndentationError: expected an indented block after 'for' statement on line 1 (3695896917.py, line 2)"
  },
  {
    "objectID": "w01/slides.html#type-hints",
    "href": "w01/slides.html#type-hints",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Type Hints",
    "text": "Type Hints\n\nNot a “standard” Python feature, not enforced by the Python interpreter, but can help you maintain sanity!\n\n\n\n\n\nCode\ndef multiply(thing1, thing2):\n  return thing1 * thing2\nprint(multiply(5, 3))\nprint(multiply(\"fiveee\", 3))\n\n\n15\nfiveeefiveeefiveee\n\n\n\n\n\nCode\nfrom numbers import Number\ndef multiply(thing1: Number, thing2: Number) -&gt; Number:\n  return thing1 * thing2\nprint(multiply(5, 3))\nprint(multiply(\"fiveee\", 3))\n\n\n15\nfiveeefiveeefiveee\n\n\n\n\n\n\nCode\nfrom mypy import api\nresult = api.run(['-c',_i])\nprint(result[0])\n\n\n&lt;string&gt;:3: error: Unsupported left operand type for * (\"Number\")  [operator]\n&lt;string&gt;:4: error: Argument 1 to \"multiply\" has incompatible type \"int\"; expected \"Number\"  [arg-type]\n&lt;string&gt;:4: note: Types from \"numbers\" aren't supported for static type checking\n&lt;string&gt;:4: note: See https://peps.python.org/pep-0484/#the-numeric-tower\n&lt;string&gt;:4: note: Consider using a protocol instead, such as typing.SupportsFloat\n&lt;string&gt;:4: error: Argument 2 to \"multiply\" has incompatible type \"int\"; expected \"Number\"  [arg-type]\n&lt;string&gt;:5: error: Argument 1 to \"multiply\" has incompatible type \"str\"; expected \"Number\"  [arg-type]\n&lt;string&gt;:5: note: Types from \"numbers\" aren't supported for static type checking\n&lt;string&gt;:5: note: See https://peps.python.org/pep-0484/#the-numeric-tower\n&lt;string&gt;:5: note: Consider using a protocol instead, such as typing.SupportsFloat\n&lt;string&gt;:5: error: Argument 2 to \"multiply\" has incompatible type \"int\"; expected \"Number\"  [arg-type]\nFound 5 errors in 1 file (checked 1 source file)"
  },
  {
    "objectID": "w01/slides.html#unit-testing",
    "href": "w01/slides.html#unit-testing",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Unit Testing",
    "text": "Unit Testing\n\nFor your life: test-driven development\n\nIf you’re coding a duck, you should test that it looks like a duck, quacks like a duck, etc.\n\nFor this class:\n\nPublic tests: Fully visible, see result plus full code\nHidden tests: See result + description of test, but no code\nSecret tests: We run these after you submit, as a major portion of the total grade"
  },
  {
    "objectID": "w01/slides.html#why-does-the-nyc-subway-have-express-lines",
    "href": "w01/slides.html#why-does-the-nyc-subway-have-express-lines",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Why Does The NYC Subway Have Express Lines?",
    "text": "Why Does The NYC Subway Have Express Lines?\n\nFrom NYC Central Park website"
  },
  {
    "objectID": "w01/slides.html#why-stop-at-two-levels",
    "href": "w01/slides.html#why-stop-at-two-levels",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Why Stop At Two Levels?",
    "text": "Why Stop At Two Levels?\n\nFrom Skip List Data Structure Explained, Sumit’s Diary blog"
  },
  {
    "objectID": "w01/slides.html#how-tf-does-google-maps-work",
    "href": "w01/slides.html#how-tf-does-google-maps-work",
    "title": "Week 1: Course Intro and Motivation",
    "section": "How TF Does Google Maps Work?",
    "text": "How TF Does Google Maps Work?\n\nA (mostly) full-on answer: soon to come! Data structures for spatial data\nA step in that direction: Quadtrees! (Fractal DC)\n\n\nJim Kang’s Quadtree Visualizations"
  },
  {
    "objectID": "w01/slides.html#the-secretly-exciting-world-of-matrix-multiplication",
    "href": "w01/slides.html#the-secretly-exciting-world-of-matrix-multiplication",
    "title": "Week 1: Course Intro and Motivation",
    "section": "The Secretly Exciting World of Matrix Multiplication",
    "text": "The Secretly Exciting World of Matrix Multiplication\n\nFun Fact 1: Most of modern Machine Learning is, at the processor level, just a bunch of matrix operations\nFun Fact 2: The way we’ve all learned how to multiply matrices requires \\(O(N^3)\\) operations, for two \\(N \\times N\\) matrices \\(A\\) and \\(B\\)\nFun Fact 3: \\(\\underbrace{x^2 - y^2}_{\\mathclap{\\times\\text{ twice, }\\pm\\text{ once}}} = \\underbrace{(x+y)(x-y)}_{\\times\\text{once, }\\pm\\text{ twice}}\\)\nFun Fact 4: These are not very fun facts at all"
  },
  {
    "objectID": "w01/slides.html#why-is-jeff-rambling-about-matrix-math-from-300-years-ago",
    "href": "w01/slides.html#why-is-jeff-rambling-about-matrix-math-from-300-years-ago",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Why Is Jeff Rambling About Matrix Math From 300 Years Ago?",
    "text": "Why Is Jeff Rambling About Matrix Math From 300 Years Ago?\n\nThe way we all learned it in school (for \\(N = 2\\)):\n\n\\[\nAB = \\begin{bmatrix}\na_{11} & a_{12} \\\\\na_{21} & a_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\nb_{11} & b_{12} \\\\\nb_{21} & b_{22}\n\\end{bmatrix} =\n\\begin{bmatrix}\na_{11}b_{11} + a_{12}b_{21} & a_{11}b_{12} + a_{12}b_{22} \\\\\na_{21}b_{11} + a_{22}b_{21} & a_{21}b_{12} + a_{22}b_{22}\n\\end{bmatrix}\n\\]\n\n12 operations: 8 multiplications, 4 additions \\(\\implies O(N^3) = O(2^3) = O(8)\\)\nAre we trapped? Like… what is there to do besides performing these \\(N^3\\) operations, if we want to multiply two \\(N \\times N\\) matrices? Why are we about to move onto yet another slide about this?"
  },
  {
    "objectID": "w01/slides.html#block-partitioning-matrices",
    "href": "w01/slides.html#block-partitioning-matrices",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Block-Partitioning Matrices",
    "text": "Block-Partitioning Matrices\n\nNow let’s consider big matrices, whose dimensions are a power of 2 (for ease of illustration): \\(A\\) and \\(B\\) are now \\(N \\times N = 2^n \\times 2^n\\) matrices\nWe can “decompose” the matrix product \\(AB\\) as:\n\n\\[\nAB = \\begin{bmatrix}\nA_{11} & A_{12} \\\\\nA_{21} & A_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\nB_{11} & B_{12} \\\\\nB_{21} & B_{22}\n\\end{bmatrix} =\n\\begin{bmatrix}\nA_{11}B_{11} + A_{12}B_{21} & A_{11}B_{12} + A_{12}B_{22} \\\\\nA_{21}B_{11} + A_{22}B_{21} & A_{21}B_{12} + A_{22}B_{22}\n\\end{bmatrix}\n\\]\n\nWhich gives us a recurrence relation representing the total number of computations required for this big-matrix multiplication: \\(T(N) = \\underbrace{8T(N/2)}_{\\text{Multiplications}} + \\underbrace{\\Theta(1)}_{\\text{Additions}}\\)\nIt turns out that (using a method we’ll learn in Week 3), given this recurrence relation and our base case from the previous slide, this divide-and-conquer approach via block-partitioning doesn’t help us: we still get \\(T(n) = O(n^3)\\)…\nSo why is Jeff still torturing us with this example?"
  },
  {
    "objectID": "w01/slides.html#time-for-some-matrix-magic",
    "href": "w01/slides.html#time-for-some-matrix-magic",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Time For Some 🪄🔥MATRIX MAGIC!🔥🪄",
    "text": "Time For Some 🪄🔥MATRIX MAGIC!🔥🪄\n\n\nIf we define\n\n\\[\n\\begin{align*}\nm_1 &= (a_{11}+a_{22})(b_{11}+b_{22}) \\\\\nm_2 &= (a_{21}+a_{22})b_{11} \\\\\nm_3 &= a_{11}(b_{12}-b_{22}) \\\\\nm_4 &= a_{22}(b_{21}-b_{11}) \\\\\nm_5 &= (a_{11}+a_{12})b_{22} \\\\\nm_6 &= (a_{21}-a_{11})(b_{11}+b_{12}) \\\\\nm_7 &= (a_{12}-a_{22})(b_{21}+b_{22})\n\\end{align*}\n\\]\n\n\n\nThen we can combine these seven scalar products to obtain our matrix product:\n\n\\[\nAB = \\begin{bmatrix}\nm_1 + m_4 - m_5 + m_7 & m_3 + m_5 \\\\\nm_2 + m_4 & m_1 - m_2 + m_3 + m_6\n\\end{bmatrix}\n\\]\n\n\nTotal operations: 7 multiplications, 18 additions"
  },
  {
    "objectID": "w01/slides.html#block-partitioned-matrix-magic",
    "href": "w01/slides.html#block-partitioned-matrix-magic",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Block-Partitioned Matrix Magic",
    "text": "Block-Partitioned Matrix Magic\n\nUsing the previous slide as our base case and applying this same method to the block-paritioned big matrices, we get the same result, but where the four entries in \\(AB\\) here are now matrices rather than scalars:\n\n\\[\nAB = \\begin{bmatrix}\nM_1 + M_4 - M_5 + M_7 & M_3 + M_5 \\\\\nM_2 + M_4 & M_1 - M_2 + M_3 + M_6\n\\end{bmatrix}\n\\]\n\nWe now have a different recurrence relation: \\(T(N) = \\underbrace{7T(N/2)}_{\\text{Multiplications}} + \\underbrace{\\Theta(N^2)}_{\\text{Additions}}\\)\nAnd it turns out, somewhat miraculously, that the additional time required for the increased number of additions is significantly less than the time savings we obtain by doing 7 instead of 8 multiplications, since this method now runs in \\(T(N) = O(N^{\\log_2(7)}) \\approx O(N^{2.807}) &lt; O(N^3)\\) 🤯"
  },
  {
    "objectID": "w01/index.html",
    "href": "w01/index.html",
    "title": "Week 1: Course Intro and Motivation",
    "section": "",
    "text": "Open slides in new window →",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#before-and-after",
    "href": "w01/index.html#before-and-after",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Before and After",
    "text": "Before and After\n\n\n\n\n\n\n\n\n\nPython before taking DSAN 5500\n\n\n\n\n\n\n\nPython after taking DSAN 5500",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#developing-a-comparative-understanding",
    "href": "w01/index.html#developing-a-comparative-understanding",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Developing a Comparative Understanding",
    "text": "Developing a Comparative Understanding\n\n\n\n\n\n\n\n\n\n“We hardly know ourselves, if we know nobody else”\n\n\n–(Blue Scholars, “Sagaba”)\n\n\n\n\n\n\nThe course focuses on Python, but part of understanding Python is understanding how Python does things differently from other languages!\nJust as C was “overtaken” by Java, then Java was “overtaken” by Python, Python will someday be overtaken",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#the-numbers",
    "href": "w01/index.html#the-numbers",
    "title": "Week 1: Course Intro and Motivation",
    "section": "The Numbers",
    "text": "The Numbers\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nlang_df = pd.read_csv(\"assets/gh_issues.csv\")\n# The data for 2022 is essentially useless\nlang_df = lang_df[lang_df['year'] &lt;= 2021].copy()\nlang_df['time'] = lang_df['year'].astype(str) + \"_\" + lang_df['quarter'].astype(str)\nlang_df['prop'] = lang_df['count'] / lang_df.groupby('time')['count'].transform('sum')\nlang_df.head()\n#sns.lineplot(data=lang_df, x='year', y='count', color='name')\n# Keep only most popular languages\nkeep_langs = ['Python','JavaScript','C','C++','C#','Java','Ruby']\npop_df = lang_df[lang_df['name'].isin(keep_langs)].copy()\nfig = px.line(pop_df,\n  x='time', y='prop', color='name',\n  template='simple_white', title='Programming Language Popularity Since 2012',\n  labels = {\n    'time': 'Year',\n    'prop': 'Proportion of GitHub Issues'\n  }\n)\nfig.update_layout(\n  xaxis = dict(\n    tickmode = 'array',\n    tickvals = [f\"{year}_1\" for year in range(2012,2022)],\n    ticktext = [f\"{year}\" for year in range(2012,2022)]\n  )\n)\nfig.show()",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#research-particular-subfields",
    "href": "w01/index.html#research-particular-subfields",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Research Particular Subfields!",
    "text": "Research Particular Subfields!\n\nFor example, if you’re interested in pursuing Economics, you’ll want to learn Stata\nPhysics? You may want to learn MATLAB\nFor pure mathematics: Julia / Mathematica\nStatistics, sociology, psychology, political science: R\nWeb development: JavaScript / TypeScript\nThe holy grail: you’re comfortable with Python but can also think in general, language-agnostic terms about algorithmic and data-structural efficiency!",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#avoid-analysis-paralysis",
    "href": "w01/index.html#avoid-analysis-paralysis",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Avoid Analysis Paralysis",
    "text": "Avoid Analysis Paralysis\n\n(Easier said than done, admittedly…)\n\n\n\n\nImage source: XKCD",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#tie-yourself-to-the-mast",
    "href": "w01/index.html#tie-yourself-to-the-mast",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Tie Yourself to the Mast",
    "text": "Tie Yourself to the Mast\n\nThe exhausted 3am version of you will thank present you for writing useful comments, exceptions/errors, and type hints!\n\n\n\n\nJohn William Waterhouse, Public domain, via Wikimedia Commons",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#types-of-languages",
    "href": "w01/index.html#types-of-languages",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Types of Languages",
    "text": "Types of Languages\n\nCompiled\nInterpreted",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#primitive-types",
    "href": "w01/index.html#primitive-types",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Primitive Types",
    "text": "Primitive Types\n\nBoolean (True or False)\nNumbers (Integers, Decimals)\nStrings\nNone",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#stack-and-heap",
    "href": "w01/index.html#stack-and-heap",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Stack and Heap",
    "text": "Stack and Heap\nLet’s look at what happens, in the computer’s memory, when we run the following code:\n\n\n\n\nCode\nimport datetime\nimport pandas as pd\ncountry_df = pd.read_csv(\"assets/country_pop.csv\")\npop_col = country_df['pop']\nnum_rows = len(country_df)\nfilled = all(~pd.isna(country_df))\nalg_row = country_df.loc[country_df['name'] == \"Algeria\"]\nnum_cols = len(country_df.columns)\nusername = \"Jeff\"\ncur_date = datetime.datetime.now()\ni = 0\nj = None\nz = 314\ncountry_df\n\n\n\n\n\n\n\n\n\nname\npop\n\n\n\n\n0\nAlbania\n2.8\n\n\n1\nAlgeria\n44.2\n\n\n2\nAngola\n34.5",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#algorithmic-thinking",
    "href": "w01/index.html#algorithmic-thinking",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Algorithmic Thinking",
    "text": "Algorithmic Thinking\n\nWhat are the inputs?\nWhat are the outputs?\nStandard cases vs. edge cases\nAdversarial development: brainstorm all of the ways an evil hacker might break your code!",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#example-finding-an-item-within-a-list",
    "href": "w01/index.html#example-finding-an-item-within-a-list",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Example: Finding An Item Within A List",
    "text": "Example: Finding An Item Within A List\n\nSeems straightforward, right? Given a list l, and a value v, return the index of l which contains v\nCorner cases galore…\nWhat if l contains v more than once? What if it doesn’t contain v at all? What if l is None? What if v is None? What if l isn’t a list at all? What if v is itself a list?",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#sanity-preserving-tip",
    "href": "w01/index.html#sanity-preserving-tip",
    "title": "Week 1: Course Intro and Motivation",
    "section": "#1 Sanity-Preserving Tip!",
    "text": "#1 Sanity-Preserving Tip!\n\n(For our purposes) the answer to “what is Python?” is: an executable file that runs .py files!\n\ne.g., we can run python mycode.py in Terminal/PowerShell\n\nEverything else: pip, Jupyter, Pandas, etc., is an add-on to this basic functionality!",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#code-blocks-via-indentation",
    "href": "w01/index.html#code-blocks-via-indentation",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Code Blocks via Indentation",
    "text": "Code Blocks via Indentation\n\n\nCode\nfor i in range(5):\n    print(i)\n\n\n0\n1\n2\n3\n4\n\n\n\n\nCode\nfor i in range(5):\nprint(i)\n\n\nIndentationError: expected an indented block after 'for' statement on line 1 (3695896917.py, line 2)",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#type-hints",
    "href": "w01/index.html#type-hints",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Type Hints",
    "text": "Type Hints\n\nNot a “standard” Python feature, not enforced by the Python interpreter, but can help you maintain sanity!\n\n\n\n\n\nCode\ndef multiply(thing1, thing2):\n  return thing1 * thing2\nprint(multiply(5, 3))\nprint(multiply(\"fiveee\", 3))\n\n\n15\nfiveeefiveeefiveee\n\n\n\n\n\nCode\nfrom numbers import Number\ndef multiply(thing1: Number, thing2: Number) -&gt; Number:\n  return thing1 * thing2\nprint(multiply(5, 3))\nprint(multiply(\"fiveee\", 3))\n\n\n15\nfiveeefiveeefiveee\n\n\n\n\n\n\nCode\nfrom mypy import api\nresult = api.run(['-c',_i])\nprint(result[0])\n\n\n&lt;string&gt;:3: error: Unsupported left operand type for * (\"Number\")  [operator]\n&lt;string&gt;:4: error: Argument 1 to \"multiply\" has incompatible type \"int\"; expected \"Number\"  [arg-type]\n&lt;string&gt;:4: note: Types from \"numbers\" aren't supported for static type checking\n&lt;string&gt;:4: note: See https://peps.python.org/pep-0484/#the-numeric-tower\n&lt;string&gt;:4: note: Consider using a protocol instead, such as typing.SupportsFloat\n&lt;string&gt;:4: error: Argument 2 to \"multiply\" has incompatible type \"int\"; expected \"Number\"  [arg-type]\n&lt;string&gt;:5: error: Argument 1 to \"multiply\" has incompatible type \"str\"; expected \"Number\"  [arg-type]\n&lt;string&gt;:5: note: Types from \"numbers\" aren't supported for static type checking\n&lt;string&gt;:5: note: See https://peps.python.org/pep-0484/#the-numeric-tower\n&lt;string&gt;:5: note: Consider using a protocol instead, such as typing.SupportsFloat\n&lt;string&gt;:5: error: Argument 2 to \"multiply\" has incompatible type \"int\"; expected \"Number\"  [arg-type]\nFound 5 errors in 1 file (checked 1 source file)",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#unit-testing",
    "href": "w01/index.html#unit-testing",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Unit Testing",
    "text": "Unit Testing\n\nFor your life: test-driven development\n\nIf you’re coding a duck, you should test that it looks like a duck, quacks like a duck, etc.\n\nFor this class:\n\nPublic tests: Fully visible, see result plus full code\nHidden tests: See result + description of test, but no code\nSecret tests: We run these after you submit, as a major portion of the total grade",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#why-does-the-nyc-subway-have-express-lines",
    "href": "w01/index.html#why-does-the-nyc-subway-have-express-lines",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Why Does The NYC Subway Have Express Lines?",
    "text": "Why Does The NYC Subway Have Express Lines?\n\n\n\nFrom NYC Central Park website",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#why-stop-at-two-levels",
    "href": "w01/index.html#why-stop-at-two-levels",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Why Stop At Two Levels?",
    "text": "Why Stop At Two Levels?\n\n\n\nFrom Skip List Data Structure Explained, Sumit’s Diary blog",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#how-tf-does-google-maps-work",
    "href": "w01/index.html#how-tf-does-google-maps-work",
    "title": "Week 1: Course Intro and Motivation",
    "section": "How TF Does Google Maps Work?",
    "text": "How TF Does Google Maps Work?\n\nA (mostly) full-on answer: soon to come! Data structures for spatial data\nA step in that direction: Quadtrees! (Fractal DC)\n\n\nJim Kang’s Quadtree Visualizations",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#the-secretly-exciting-world-of-matrix-multiplication",
    "href": "w01/index.html#the-secretly-exciting-world-of-matrix-multiplication",
    "title": "Week 1: Course Intro and Motivation",
    "section": "The Secretly Exciting World of Matrix Multiplication",
    "text": "The Secretly Exciting World of Matrix Multiplication\n\nFun Fact 1: Most of modern Machine Learning is, at the processor level, just a bunch of matrix operations\nFun Fact 2: The way we’ve all learned how to multiply matrices requires \\(O(N^3)\\) operations, for two \\(N \\times N\\) matrices \\(A\\) and \\(B\\)\nFun Fact 3: \\(\\underbrace{x^2 - y^2}_{\\mathclap{\\times\\text{ twice, }\\pm\\text{ once}}} = \\underbrace{(x+y)(x-y)}_{\\times\\text{once, }\\pm\\text{ twice}}\\)\nFun Fact 4: These are not very fun facts at all",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#why-is-jeff-rambling-about-matrix-math-from-300-years-ago",
    "href": "w01/index.html#why-is-jeff-rambling-about-matrix-math-from-300-years-ago",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Why Is Jeff Rambling About Matrix Math From 300 Years Ago?",
    "text": "Why Is Jeff Rambling About Matrix Math From 300 Years Ago?\n\nThe way we all learned it in school (for \\(N = 2\\)):\n\n\\[\nAB = \\begin{bmatrix}\na_{11} & a_{12} \\\\\na_{21} & a_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\nb_{11} & b_{12} \\\\\nb_{21} & b_{22}\n\\end{bmatrix} =\n\\begin{bmatrix}\na_{11}b_{11} + a_{12}b_{21} & a_{11}b_{12} + a_{12}b_{22} \\\\\na_{21}b_{11} + a_{22}b_{21} & a_{21}b_{12} + a_{22}b_{22}\n\\end{bmatrix}\n\\]\n\n12 operations: 8 multiplications, 4 additions \\(\\implies O(N^3) = O(2^3) = O(8)\\)\nAre we trapped? Like… what is there to do besides performing these \\(N^3\\) operations, if we want to multiply two \\(N \\times N\\) matrices? Why are we about to move onto yet another slide about this?",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#block-partitioning-matrices",
    "href": "w01/index.html#block-partitioning-matrices",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Block-Partitioning Matrices",
    "text": "Block-Partitioning Matrices\n\nNow let’s consider big matrices, whose dimensions are a power of 2 (for ease of illustration): \\(A\\) and \\(B\\) are now \\(N \\times N = 2^n \\times 2^n\\) matrices\nWe can “decompose” the matrix product \\(AB\\) as:\n\n\\[\nAB = \\begin{bmatrix}\nA_{11} & A_{12} \\\\\nA_{21} & A_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\nB_{11} & B_{12} \\\\\nB_{21} & B_{22}\n\\end{bmatrix} =\n\\begin{bmatrix}\nA_{11}B_{11} + A_{12}B_{21} & A_{11}B_{12} + A_{12}B_{22} \\\\\nA_{21}B_{11} + A_{22}B_{21} & A_{21}B_{12} + A_{22}B_{22}\n\\end{bmatrix}\n\\]\n\nWhich gives us a recurrence relation representing the total number of computations required for this big-matrix multiplication: \\(T(N) = \\underbrace{8T(N/2)}_{\\text{Multiplications}} + \\underbrace{\\Theta(1)}_{\\text{Additions}}\\)\nIt turns out that (using a method we’ll learn in Week 3), given this recurrence relation and our base case from the previous slide, this divide-and-conquer approach via block-partitioning doesn’t help us: we still get \\(T(n) = O(n^3)\\)…\nSo why is Jeff still torturing us with this example?",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#time-for-some-matrix-magic",
    "href": "w01/index.html#time-for-some-matrix-magic",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Time For Some 🪄🔥MATRIX MAGIC!🔥🪄",
    "text": "Time For Some 🪄🔥MATRIX MAGIC!🔥🪄\n\n\nIf we define\n\n\\[\n\\begin{align*}\nm_1 &= (a_{11}+a_{22})(b_{11}+b_{22}) \\\\\nm_2 &= (a_{21}+a_{22})b_{11} \\\\\nm_3 &= a_{11}(b_{12}-b_{22}) \\\\\nm_4 &= a_{22}(b_{21}-b_{11}) \\\\\nm_5 &= (a_{11}+a_{12})b_{22} \\\\\nm_6 &= (a_{21}-a_{11})(b_{11}+b_{12}) \\\\\nm_7 &= (a_{12}-a_{22})(b_{21}+b_{22})\n\\end{align*}\n\\]\n\n\n\nThen we can combine these seven scalar products to obtain our matrix product:\n\n\\[\nAB = \\begin{bmatrix}\nm_1 + m_4 - m_5 + m_7 & m_3 + m_5 \\\\\nm_2 + m_4 & m_1 - m_2 + m_3 + m_6\n\\end{bmatrix}\n\\]\n\n\nTotal operations: 7 multiplications, 18 additions",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "w01/index.html#block-partitioned-matrix-magic",
    "href": "w01/index.html#block-partitioned-matrix-magic",
    "title": "Week 1: Course Intro and Motivation",
    "section": "Block-Partitioned Matrix Magic",
    "text": "Block-Partitioned Matrix Magic\n\nUsing the previous slide as our base case and applying this same method to the block-paritioned big matrices, we get the same result, but where the four entries in \\(AB\\) here are now matrices rather than scalars:\n\n\\[\nAB = \\begin{bmatrix}\nM_1 + M_4 - M_5 + M_7 & M_3 + M_5 \\\\\nM_2 + M_4 & M_1 - M_2 + M_3 + M_6\n\\end{bmatrix}\n\\]\n\nWe now have a different recurrence relation: \\(T(N) = \\underbrace{7T(N/2)}_{\\text{Multiplications}} + \\underbrace{\\Theta(N^2)}_{\\text{Additions}}\\)\nAnd it turns out, somewhat miraculously, that the additional time required for the increased number of additions is significantly less than the time savings we obtain by doing 7 instead of 8 multiplications, since this method now runs in \\(T(N) = O(N^{\\log_2(7)}) \\approx O(N^{2.807}) &lt; O(N^3)\\) 🤯",
    "crumbs": [
      "Week 1: Jan 10"
    ]
  },
  {
    "objectID": "recordings/index.html",
    "href": "recordings/index.html",
    "title": "Lecture Recordings",
    "section": "",
    "text": "Week\n\n\nTitle\n\n\nDate\n\n\n\n\n\n\n3\n\n\nW03 Lecture\n\n\nMonday Jan 29, 2024\n\n\n\n\n2\n\n\nW02 Lecture\n\n\nMonday Jan 22, 2024\n\n\n\n\n1\n\n\nW01 Lecture\n\n\nWednesday Jan 10, 2024\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Recordings"
    ]
  },
  {
    "objectID": "assignments.html",
    "href": "assignments.html",
    "title": "Assignment Point Distributions",
    "section": "",
    "text": "Use the tabs at the bottom of the spreadsheet (e.g., click the label HW1) to view the point distributions for different assignments.\nThe distributions are imported from a Google Sheet mainly for transparency: so that you can see exactly how totals are computed as a sum of the individual points allocated for each test!",
    "crumbs": [
      "Assignments"
    ]
  },
  {
    "objectID": "w03/slides.html#data-structure-choice-leftrightarrow-efficiency-for-task",
    "href": "w03/slides.html#data-structure-choice-leftrightarrow-efficiency-for-task",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Data Structure Choice \\(\\Leftrightarrow\\) Efficiency for Task",
    "text": "Data Structure Choice \\(\\Leftrightarrow\\) Efficiency for Task\n\nDo we need to be able to insert quickly?\nDo we need to be able to sort quickly?\nDo we need to be able to search quickly?\nAre we searching for individual items or for ranges?"
  },
  {
    "objectID": "w03/slides.html#recall-primitives",
    "href": "w03/slides.html#recall-primitives",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Recall: Primitives",
    "text": "Recall: Primitives\n\nbool\nint\nfloat\nNone\nNow we want to put these together, to form… structures! 👀\nStructures are the things that live in the heap; the stack just points to them"
  },
  {
    "objectID": "w03/slides.html#tuples",
    "href": "w03/slides.html#tuples",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Tuples",
    "text": "Tuples\n\nFixed-size collection of \\(N\\) objects\nUnless otherwise specified, we’re talking about \\(2\\)-tuples\nExample: We can locate something on the Earth by specifying two floats: latitude and longitude!\n\n\n\nCode\ngtown_loc = (38.9076, -77.0723)\ngtown_loc\n\n\n(38.9076, -77.0723)\n\n\n\nBut what if we don’t know in advance how many items we want to store? Ex: how can we store users for a new app?"
  },
  {
    "objectID": "w03/slides.html#sequences",
    "href": "w03/slides.html#sequences",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Sequences",
    "text": "Sequences\n\nIn General: Mapping of integer indices to objects\nx = ['a','b','c']\n\n\\(\\implies\\) x[0] = 'a'\n\\(\\implies\\) x[1] = 'b'\n\\(\\implies\\) x[2] = 'c'\n\nIn Python: list\nNice built-in language constructs for looping over lists, and especially for performing operations on each element"
  },
  {
    "objectID": "w03/slides.html#looping-over-sequences",
    "href": "w03/slides.html#looping-over-sequences",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Looping Over Sequences",
    "text": "Looping Over Sequences\n\n\n\nC/C++/Java:\n\nList&lt;String&gt; myList = Arrays.asList(\"a\", \"b\", \"c\");\nfor (int i = 0; i &lt; x.size(); i++) {\n    System.out.println(myList.get(i));\n}\n\na\nb\nc\n\n\n\nPython:\n\n\n\nCode\nmy_list = ['a','b','c']\nfor list_element in my_list:\n  print(list_element)\n\n\na\nb\nc"
  },
  {
    "objectID": "w03/slides.html#list-comprehensions-apply-function-to-each-element",
    "href": "w03/slides.html#list-comprehensions-apply-function-to-each-element",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "List Comprehensions: Apply Function to Each Element",
    "text": "List Comprehensions: Apply Function to Each Element\n\nConstruct new list by applying operation to each element:\n\n\n\nCode\nmy_nums = [4,5,6,7]\nmy_squares = [num ** 2 for num in my_nums]\nmy_squares\n\n\n[16, 25, 36, 49]\n\n\n\nCan also filter the elements of the list with if:\n\n\n\nCode\nmy_odd_squares = [num ** 2 for num in my_nums if num % 2 == 1]\nmy_odd_squares\n\n\n[25, 49]"
  },
  {
    "objectID": "w03/slides.html#sets",
    "href": "w03/slides.html#sets",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Sets",
    "text": "Sets\n\n\n\nExtremely helpful + efficient for finding unique elements:\n\n\n\nCode\nanimals_i_saw = ['bird','bird','fish','bird','cat','bird','lizard']\nprint(f\"Number of animals I saw: {len(animals_i_saw)}\")\n\n\nNumber of animals I saw: 7\n\n\n\n\nCode\nunique_animals_me = set(animals_i_saw)\nprint(f\"Set of unique animals: {unique_animals_me}\")\nprint(f\"Number of unique animals: {len(unique_animals_me)}\")\n\n\nSet of unique animals: {'fish', 'cat', 'lizard', 'bird'}\nNumber of unique animals: 4\n\n\n\n\nSupports all set operators from math:\n\n\n\nCode\nanimals_you_saw = ['lizard','dog','bird','bird','bird']\nunique_animals_you = set(animals_you_saw)\nunique_animals_both = unique_animals_me.intersection(unique_animals_you)\nprint(f\"Animals we both saw: {unique_animals_both}\")\n\n\nAnimals we both saw: {'lizard', 'bird'}\n\n\n\n\nCode\nunique_animals_either = unique_animals_me.union(unique_animals_you)\nprint(f\"Animals either of us saw: {unique_animals_either}\")\n\n\nAnimals either of us saw: {'cat', 'fish', 'dog', 'lizard', 'bird'}\n\n\n\n\nCode\nunique_animals_meonly = unique_animals_me - unique_animals_you\nprint(f\"Animals I saw that you didn't see: {unique_animals_meonly}\")\nunique_animals_youonly = unique_animals_you - unique_animals_me\nprint(f\"Animals you saw that I didn't see: {unique_animals_youonly}\")\n\n\nAnimals I saw that you didn't see: {'fish', 'cat'}\nAnimals you saw that I didn't see: {'dog'}"
  },
  {
    "objectID": "w03/slides.html#maps-dictionaries",
    "href": "w03/slides.html#maps-dictionaries",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Maps / Dictionaries",
    "text": "Maps / Dictionaries\n\n\n\nWhile other language like Java have lots of fancy types of Map, Python has a single type, the dictionary:\n\n\n\nCode\ngtown_data = {\n  'name': 'Georgetown University',\n  'founded': 1789,\n  'coordinates': (38.9076, -77.0723),\n  'location': {\n    'city': 'Washington',\n    'state': 'DC', # &lt;__&lt;\n    'country': 'USA'\n  }\n}\nprint(gtown_data.keys())\nprint(gtown_data.values())\n\n\ndict_keys(['name', 'founded', 'coordinates', 'location'])\ndict_values(['Georgetown University', 1789, (38.9076, -77.0723), {'city': 'Washington', 'state': 'DC', 'country': 'USA'}])\n\n\n\n\nBe careful when looping! Default behavior is iteration over keys:\n\n\n\nCode\nfor k in gtown_data:\n  print(k)\n\n\nname\nfounded\ncoordinates\nlocation\n\n\n\nFor key-value pairs use .items():\n\n\n\nCode\nfor k, v in gtown_data.items():\n  print(k, v)\n\n\nname Georgetown University\nfounded 1789\ncoordinates (38.9076, -77.0723)\nlocation {'city': 'Washington', 'state': 'DC', 'country': 'USA'}"
  },
  {
    "objectID": "w03/slides.html#looking-under-the-hood-of-a-data-structure",
    "href": "w03/slides.html#looking-under-the-hood-of-a-data-structure",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Looking Under the Hood of a Data Structure",
    "text": "Looking Under the Hood of a Data Structure\n\nLast week we saw the math for why we can “abstract away from” the details of how a particular language works\nWe want to understand these structures independently of the specifics of their implementation in Python (for now)\nSo, let’s construct our own simplified versions of the basic structures, and use these simplified versions to get a sense for their efficiency\n\n(The “true” Python versions may be hyper-optimized, but as we saw, there are fundamental constraints on runtime, assuming \\(P \\neq NP\\))"
  },
  {
    "objectID": "w03/slides.html#tuples-1",
    "href": "w03/slides.html#tuples-1",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Tuples",
    "text": "Tuples\n\n\nCode\nclass MyTuple:\n  def __init__(self, thing1, thing2):\n    self.thing1 = thing1\n    self.thing2 = thing2\n\n  def __repr__(self):\n    return f\"({self.thing1}, {self.thing2})\"\n\n  def __str__(self):\n    return self.__repr__()\n\nt1 = MyTuple('a','b')\nt2 = MyTuple(111, 222)\nprint(t1, t2)\n\n\n(a, b) (111, 222)"
  },
  {
    "objectID": "w03/slides.html#lists",
    "href": "w03/slides.html#lists",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Lists",
    "text": "Lists\n\n\n\nThe list itself just points to a root item:\n\n\n\nCode\nclass MyList:\n  def __init__(self):\n    self.root = None\n\n  def append(self, new_item):\n    if self.root is None:\n      self.root = MyListItem(new_item)\n    else:\n      self.root.append(new_item)\n\n  def __repr__(self):\n    return self.root.__repr__()\n\n\n\n\nAn item has contents, pointer to next item:\n\n\n\nCode\nclass MyListItem:\n  def __init__(self, content):\n    self.content = content\n    self.next = None\n\n  def append(self, new_item):\n    if self.next is None:\n      self.next = MyListItem(new_item)\n    else:\n      self.next.append(new_item)\n\n  def __repr__(self):\n    my_content = self.content\n    return my_content if self.next is None else f\"{my_content}, {self.next.__repr__()}\"\n\n\n\n\n\n\nCode\nusers = MyList()\nusers.append('Jeff')\nusers.append('Alma')\nusers.append('Bo')\nprint(users)\n\n\nJeff, Alma, Bo"
  },
  {
    "objectID": "w03/slides.html#so-how-many-steps-are-required",
    "href": "w03/slides.html#so-how-many-steps-are-required",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "So, How Many “Steps” Are Required…",
    "text": "So, How Many “Steps” Are Required…\n\nTo retrieve the first element in a MyTuple?\nTo retrieve the last element in a MyTuple?\nTo retrieve the first element in a MyList?\nTo retrieve the last element in a MyList?"
  },
  {
    "objectID": "w03/slides.html#how-many-steps",
    "href": "w03/slides.html#how-many-steps",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "How Many Steps?",
    "text": "How Many Steps?\n\n\n\nWith a MyTuple:\n\n\n\nCode\nt1.thing1\n\n\n'a'\n\n\n\n\\(\\implies\\) 1 step\n\n\n\nCode\nt1.thing2\n\n\n'b'\n\n\n\n\\(\\implies\\) 1 step\n\n\n\nWith a MyList:\n\n\n\nCode\nprint(users.root.content)\n\n\nJeff\n\n\n\n\\(\\implies\\) 1 step\n\n\n\nCode\ncurrent_node = users.root\nwhile current_node.next is not None:\n  current_node = current_node.next\nprint(current_node.content)\n\n\nBo\n\n\n\n\\(\\implies\\) (3 steps)\n…But why 3? How many steps if the list contained 5 elements? \\(N\\) elements?"
  },
  {
    "objectID": "w03/slides.html#pairwise-concatenating-list-elements",
    "href": "w03/slides.html#pairwise-concatenating-list-elements",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Pairwise-Concatenating List Elements",
    "text": "Pairwise-Concatenating List Elements\n\nNow rather than just printing, let’s pairwise concatenate:\n\n\n\nCode\ncur_pointer1 = users.root\nwhile cur_pointer1 is not None:\n  cur_pointer2 = users.root\n  while cur_pointer2 is not None:\n    print(cur_pointer1.content + cur_pointer2.content)\n    cur_pointer2 = cur_pointer2.next\n  cur_pointer1 = cur_pointer1.next\n\n\nJeffJeff\nJeffAlma\nJeffBo\nAlmaJeff\nAlmaAlma\nAlmaBo\nBoJeff\nBoAlma\nBoBo\n\n\n\nHow many steps did this take? How about for a list with \\(5\\) elements? \\(N\\) elements?"
  },
  {
    "objectID": "w03/slides.html#last-example-pairwise-concat-end-check",
    "href": "w03/slides.html#last-example-pairwise-concat-end-check",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Last Example: Pairwise-Concat + End Check",
    "text": "Last Example: Pairwise-Concat + End Check\n\n\nCode\nprinted_items = []\ncur_pointer1 = users.root\nwhile cur_pointer1 is not None:\n  cur_pointer2 = users.root\n  while cur_pointer2 is not None:\n    print(cur_pointer1.content + cur_pointer2.content)\n    printed_items.append(cur_pointer1.content)\n    printed_items.append(cur_pointer2.content)\n    cur_pointer2 = cur_pointer2.next\n  cur_pointer1 = cur_pointer1.next\ncheck_pointer = users.root\nwhile check_pointer is not None:\n  if check_pointer.content in printed_items:\n    print(f\"Phew. {check_pointer.content} printed at least once.\")\n  else:\n    print(f\"Oh no! {check_pointer.content} was never printed!!!\")\n  check_pointer = check_pointer.next\n\n\nJeffJeff\nJeffAlma\nJeffBo\nAlmaJeff\nAlmaAlma\nAlmaBo\nBoJeff\nBoAlma\nBoBo\nPhew. Jeff printed at least once.\nPhew. Alma printed at least once.\nPhew. Bo printed at least once."
  },
  {
    "objectID": "w03/slides.html#generalizing",
    "href": "w03/slides.html#generalizing",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Generalizing",
    "text": "Generalizing\n\nAlgorithms are “efficient” relative to how their runtime scales as the objects grow larger and larger!\nTuple operations take 1 step no matter what\nFor lists, retrieving the first element takes 1 step no matter what, but retrieving the last element takes \\(n\\) steps!\nPairwise concatenation requires \\(n^2\\) steps!"
  },
  {
    "objectID": "w03/slides.html#the-complexity-of-our-examples",
    "href": "w03/slides.html#the-complexity-of-our-examples",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "The Complexity of Our Examples",
    "text": "The Complexity of Our Examples\n\nTuple operations: \\(O(1)\\)\nRetrieving the first element of a list: \\(O(1)\\)\nRetrieving the last element of a list: \\(O(n)\\)\nPairwise concatenation: \\(O(n^2)\\)\nPairwise concatenation+check: \\(O(n^2 + n) = O(n^2) \\leftarrow !!!\\)\nCrucial to think asymptotically to wrap our heads around this!"
  },
  {
    "objectID": "w03/slides.html#doing-better-than-insertion-sort",
    "href": "w03/slides.html#doing-better-than-insertion-sort",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Doing Better Than Insertion Sort",
    "text": "Doing Better Than Insertion Sort\n\nIntuition Break 🥳: Finding a word in a dictionary! dsan.io/dict-lookup"
  },
  {
    "objectID": "w03/slides.html#how-can-merge-sort-work-that-much-better",
    "href": "w03/slides.html#how-can-merge-sort-work-that-much-better",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "How Can Merge Sort Work That Much Better!?",
    "text": "How Can Merge Sort Work That Much Better!?\n\nWith the linear approach, each time we check a word and it’s not our word we eliminate… one measly word 😞\nBut with the divide-and-conquer approach… we eliminate 🔥HALF OF THE REMAINING WORDS🔥"
  },
  {
    "objectID": "w03/slides.html#merging-two-sorted-lists-in-on-time",
    "href": "w03/slides.html#merging-two-sorted-lists-in-on-time",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Merging Two Sorted Lists in \\(O(n)\\) Time",
    "text": "Merging Two Sorted Lists in \\(O(n)\\) Time\n\n\nFrom Cormen et al. (2001), pg. 37"
  },
  {
    "objectID": "w03/slides.html#merge-sort-merging-as-subroutine",
    "href": "w03/slides.html#merge-sort-merging-as-subroutine",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Merge Sort (Merging as Subroutine)",
    "text": "Merge Sort (Merging as Subroutine)\n\nFrom Cormen et al. (2001), pg. 40"
  },
  {
    "objectID": "w03/slides.html#complexity-analysis",
    "href": "w03/slides.html#complexity-analysis",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Complexity Analysis",
    "text": "Complexity Analysis\n\nHard way: re-do the line-by-line analysis we did for Insertion-Sort 😣 Easy way: stand on shoulders of giants!\nUsing a famous+fun theorem (the Master Theorem): Given a recurrence \\(T(n) = aT(n/b) + f(n)\\), compute its:\n\nWatershed function \\(W(n) = n^{\\log_b(a)}\\) and\nDriving function \\(D(n) = f(n)\\)\n\nThe Master Theorem gives closed-form asymptotic solution for \\(T(n)\\), split into three cases: (1) \\(W(n)\\) grows faster than \\(D(n)\\), (2) grows at same rate as \\(D(n)\\), or (3) grows slower than \\(D(n)\\)"
  },
  {
    "objectID": "w03/slides.html#bounding-the-runtime-of-merge-sort",
    "href": "w03/slides.html#bounding-the-runtime-of-merge-sort",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Bounding the Runtime of Merge Sort",
    "text": "Bounding the Runtime of Merge Sort\n\nHow about Merge-Sort? \\(T(n) = 2T(n/2) + \\Theta(n)\\)\n\n\\(a = b = 2\\), \\(W(n) = n^{\\log_2(2)} = n\\), \\(D(n) = \\Theta(n)\\)\n\n\\(W(n)\\) and \\(D(n)\\) grow at same rate \\(\\implies\\) Case 21:\n\n\n\n\n\nApplying the Master Theorem When \\(W(n) = \\Theta(D(n))\\) (Case 2)\n\n\n\nIs there a \\(k \\geq 0\\) satisfying \\(D(n) = \\Theta(n^{\\log_b(a)}\\log_2^k(n))\\)?\nIf so, your solution is \\(T(n) = \\Theta(n^{\\log_b(a)}\\log_2^{k+1}(n))\\)\n\n\n\n\n\n\nMerge-Sort: \\(k = 0\\) works! \\(\\Theta(n^{\\log_2(2)}\\log_2^0(n)) = \\Theta(n)\\)\nThus \\(T(n) = \\Theta(n^{\\log_b(a)}\\log_2^{k+1}(n)) = \\boxed{\\Theta(n\\log_2n)}\\) 😎\n\nSee appendix slide for all 3 cases, if you’re some kind of masochist"
  },
  {
    "objectID": "w03/slides.html#breaking-a-problem-into-interacting-parts",
    "href": "w03/slides.html#breaking-a-problem-into-interacting-parts",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Breaking a Problem into (Interacting) Parts",
    "text": "Breaking a Problem into (Interacting) Parts\n\nPython so far: “Data science mode”\n\nStart at top of file with raw data\nWrite lines of code until problem solved\n\nPython in this class: “Software engineering mode”\n\nBreak system down into parts\nWrite each part separately\nLink parts together to create the whole\n\n(One implication: .py files may be easier than .ipynb for development!)"
  },
  {
    "objectID": "w03/slides.html#how-does-a-calculator-work",
    "href": "w03/slides.html#how-does-a-calculator-work",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "How Does A Calculator Work?",
    "text": "How Does A Calculator Work?\n\n(Calculator image from Wikimedia Commons)"
  },
  {
    "objectID": "w03/slides.html#key-oop-feature-1-encapsulation",
    "href": "w03/slides.html#key-oop-feature-1-encapsulation",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Key OOP Feature #1: Encapsulation",
    "text": "Key OOP Feature #1: Encapsulation\n\nImagine you’re on a team trying to make a calculator\nOne person can write the Screen class, another person can write the Button class, and so on\nNatural division of labor! (May seem silly for a calculator, but imagine as your app scales up)"
  },
  {
    "objectID": "w03/slides.html#key-oop-feature-2-abstraction",
    "href": "w03/slides.html#key-oop-feature-2-abstraction",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Key OOP Feature #2: Abstraction",
    "text": "Key OOP Feature #2: Abstraction\n\nAbstraction complements this Encapsulation: the Screen team doesn’t need to know the internal details of Button (just it’s API), and vice-versa\nRelevant data and functions can be “public”, irrelevant internal data and functions “private”\n(Like with type hints), Python doesn’t enforce this distinction, but (unlike with type hints) most libraries do separate public from private by a variable-naming convention…"
  },
  {
    "objectID": "w03/slides.html#public-protected-private-attributes-in-python",
    "href": "w03/slides.html#public-protected-private-attributes-in-python",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Public, Protected, Private Attributes in Python",
    "text": "Public, Protected, Private Attributes in Python\n\n[Public (default)] No underscores: public_var\n[Protected] One underscore: _protected_var\n[Private] Two underscores: __private_var\n\n\n\n\n\nCode\nclass MyTopSecretInfo:\n  __the_info = \"I love Carly Rae Jepsen\"\n\ninfo_obj = MyTopSecretInfo()\ninfo_obj.__the_info\n\n\nAttributeError: 'MyTopSecretInfo' object has no attribute '__the_info'\n\n\nGuess we can’t access it then, right? 😮‍💨\n\n\n\nCode\ninfo_obj._MyTopSecretInfo__the_info\n\n\n'I love Carly Rae Jepsen'\n\n\n\nNOO MY SECRET!!! 😭\nPls don’t tell anyone"
  },
  {
    "objectID": "w03/slides.html#key-oop-features-3-4-inheritance-polymorphism",
    "href": "w03/slides.html#key-oop-features-3-4-inheritance-polymorphism",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Key OOP Features #3-4: Inheritance, Polymorphism",
    "text": "Key OOP Features #3-4: Inheritance, Polymorphism\n\nBetter explained in diagrams than words (next 10 slides!), but we can get a sense by thinking about their etymology:\n“Inheritance” comes from “heir”, like “heir to the throne”\n\nParent passes on [things they possess] to their children\n\n“Polymorphism”: Poly = “many”, Morphe = “forms”\n\nHow does Python know what to do when we print()?\nIt “just works” because print() (through __str__()) takes on many (!) forms (!): each type of object has its own implementation of __str__()"
  },
  {
    "objectID": "w03/slides.html#use-case-bookstore-inventory-management",
    "href": "w03/slides.html#use-case-bookstore-inventory-management",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Use Case: Bookstore Inventory Management",
    "text": "Use Case: Bookstore Inventory Management\n\nImage source"
  },
  {
    "objectID": "w03/slides.html#in-pictures",
    "href": "w03/slides.html#in-pictures",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "In Pictures",
    "text": "In Pictures\n\n\n\n\n\n\nG\n\nBookstore Relational Diagram\n\n\nBookstore\n\nBookstore\n\nName\n\nLocation\n\nBooklist\n\nGet_Inventory()\n\nSort_Inventory()\n\n\n\nPlace\n\nPlace\n\nCity\n\nState\n\nCountry\n\nPrint_Map()\n\n\n\nBookstore:loc-&gt;Place:placehead\n\n\nHas One\n\n\n\nBook\n\nBook\n\nTitle\n\nAuthors\n\nNum Pages\n\nPreview()\n\n\n\nBookstore:bl-&gt;Book:bookhead\n\n\nHas Multiple\n\n\n\nPerson\n\nPerson\n\nFamily Name\n\nGiven Name\n\n\n\nBook:auths-&gt;Person:personhead\n\n\nHas Multiple"
  },
  {
    "objectID": "w03/slides.html#creating-classes",
    "href": "w03/slides.html#creating-classes",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Creating Classes",
    "text": "Creating Classes\n\nUse case: Creating an inventory system for a Bookstore\n\n\n\n\n\nCode\nclass Bookstore:\n    def __init__(self, name, location):\n        self.name = name\n        self.location = location\n        self.books = []\n\n    def __getitem__(self, index):\n        return self.books[index]\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return f\"Bookstore[{self.get_num_books()} books]\"\n\n    def add_books(self, book_list):\n        self.books.extend(book_list)\n\n    def get_books(self):\n        return self.books\n\n    def get_inventory(self):\n        book_lines = []\n        for book_index, book in enumerate(self.get_books()):\n            cur_book_line = f\"{book_index}. {str(book)}\"\n            book_lines.append(cur_book_line)\n        return \"\\n\".join(book_lines)\n\n    def get_num_books(self):\n        return len(self.get_books())\n\n    def sort_books(self, sort_key):\n        self.books.sort(key=sort_key)\n\nclass Book:\n    def __init__(self, title, authors, num_pages):\n        self.title = title\n        self.authors = authors\n        self.num_pages = num_pages\n\n    def __str__(self):\n        return f\"Book[title={self.get_title()}, authors={self.get_authors()}, pages={self.get_num_pages()}]\"\n\n    def get_authors(self):\n        return self.authors\n\n    def get_first_author(self):\n        return self.authors[0]\n\n    def get_num_pages(self):\n        return self.num_pages\n\n    def get_title(self):\n        return self.title\n\nclass Person:\n    def __init__(self, family_name, given_name):\n        self.family_name = family_name\n        self.given_name = given_name\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return f\"Person[{self.get_family_name()}, {self.get_given_name()}]\"\n\n    def get_family_name(self):\n        return self.family_name\n\n    def get_given_name(self):\n        return self.given_name\n\n\n\n\n\nCode\nmy_bookstore = Bookstore(\"Bookland\", \"Washington, DC\")\nplath = Person(\"Plath\", \"Sylvia\")\nbell_jar = Book(\"The Bell Jar\", [plath], 244)\nmarx = Person(\"Marx\", \"Karl\")\nengels = Person(\"Engels\", \"Friedrich\")\nmanifesto = Book(\"The Communist Manifesto\", [marx, engels], 43)\nelster = Person(\"Elster\", \"Jon\")\ncement = Book(\"The Cement of Society\", [elster], 311)\nmy_bookstore.add_books([bell_jar, manifesto, cement])\nprint(my_bookstore)\nprint(my_bookstore[0])\nprint(\"Inventory:\")\nprint(my_bookstore.get_inventory())\n\n\nBookstore[3 books]\nBook[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\nInventory:\n0. Book[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\n1. Book[title=The Communist Manifesto, authors=[Person[Marx, Karl], Person[Engels, Friedrich]], pages=43]\n2. Book[title=The Cement of Society, authors=[Person[Elster, Jon]], pages=311]"
  },
  {
    "objectID": "w03/slides.html#doing-things-with-classes",
    "href": "w03/slides.html#doing-things-with-classes",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Doing Things With Classes",
    "text": "Doing Things With Classes\n\nNow we can use our OOP structure, for example to sort the inventory in different ways!\n\n\n\n\nAlphabetical (By First Author)\n\n\n\nCode\nsort_alpha = lambda x: x.get_first_author().get_family_name()\nmy_bookstore.sort_books(sort_key = sort_alpha)\nprint(my_bookstore.get_inventory())\n\n\n0. Book[title=The Cement of Society, authors=[Person[Elster, Jon]], pages=311]\n1. Book[title=The Communist Manifesto, authors=[Person[Marx, Karl], Person[Engels, Friedrich]], pages=43]\n2. Book[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\n\n\n\n\nBy Page Count\n\n\n\nCode\nsort_pages = lambda x: x.get_num_pages()\nmy_bookstore.sort_books(sort_key = sort_pages)\nprint(my_bookstore.get_inventory())\n\n\n0. Book[title=The Communist Manifesto, authors=[Person[Marx, Karl], Person[Engels, Friedrich]], pages=43]\n1. Book[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\n2. Book[title=The Cement of Society, authors=[Person[Elster, Jon]], pages=311]"
  },
  {
    "objectID": "w03/slides.html#inheritance-and-polymorphism",
    "href": "w03/slides.html#inheritance-and-polymorphism",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Inheritance and Polymorphism",
    "text": "Inheritance and Polymorphism\n\nEncapsulate general properties in parent class, specific properties in child classes\n\n\n(You can edit this or make your own UML diagrams in nomnoml!)"
  },
  {
    "objectID": "w03/slides.html#or-is-this-better",
    "href": "w03/slides.html#or-is-this-better",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Or… Is This Better?",
    "text": "Or… Is This Better?\n\nEdit in nomnoml"
  },
  {
    "objectID": "w03/slides.html#design-choices",
    "href": "w03/slides.html#design-choices",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Design Choices",
    "text": "Design Choices\n\nThe goal is to encapsulate as best as possible: which objects should have which properties, and which methods?\nExample: Fiction vs. Non-Fiction. How important is this distinction for your use case?\n\n\n\n\nOption 1: As Property of Book\n\n\n\nCode\nfrom enum import Enum\nclass BookType(Enum):\n    NONFICTION = 0\n    FICTION = 1\n\nclass Book:\n    def __init__(self, title: str, authors: list[Person], num_pages: int, type: BookType):\n        self.title = title\n        self.authors = authors\n        self.num_pages = num_pages\n        self.type = type\n\n    def __str__(self):\n        return f\"Book[title={self.title}, authors={self.authors}, pages={self.num_pages}, type={self.type}]\"\n\n\n\n\nCode\njoyce = Person(\"Joyce\", \"James\")\nulysses = Book(\"Ulysses\", [joyce], 732, BookType.FICTION)\nschelling = Person(\"Schelling\", \"Thomas\")\nmicromotives = Book(\"Micromotives and Macrobehavior\", [schelling], 252, BookType.NONFICTION)\nprint(ulysses)\nprint(micromotives)\n\n\nBook[title=Ulysses, authors=[Person[Joyce, James]], pages=732, type=BookType.FICTION]\nBook[title=Micromotives and Macrobehavior, authors=[Person[Schelling, Thomas]], pages=252, type=BookType.NONFICTION]\n\n\n\n\nOption 2: Separate Classes\n\n\n\nCode\n# class Book defined as earlier\nclass FictionBook(Book):\n    def __init__(self, title, authors, num_pages, characters):\n        super().__init__(title, authors, num_pages)\n        self.characters = characters\n\nclass NonfictionBook(Book):\n    def __init__(self, title, authors, num_pages, topic):\n        super().__init__(title, authors, num_pages)\n        self.topic = topic\n\n\n\n\nCode\njoyce = Person(\"Joyce\", \"James\")\nulysses = FictionBook(\"Ulysses\", [joyce], 732, [\"Daedalus\"])\nschelling = Person(\"Schelling\", \"Thomas\")\nmicromotives = NonfictionBook(\"Micromotives and Macrobehavior\", [schelling], 252, \"Economics\")\nprint(ulysses)\nprint(micromotives)\n\n\nBook[title=Ulysses, authors=[Person[Joyce, James]], pages=732]\nBook[title=Micromotives and Macrobehavior, authors=[Person[Schelling, Thomas]], pages=252]"
  },
  {
    "objectID": "w03/slides.html#appendix-the-full-master-theorem",
    "href": "w03/slides.html#appendix-the-full-master-theorem",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Appendix: The Full Master Theorem",
    "text": "Appendix: The Full Master Theorem\nMaster Theorem: Let \\(a &gt; 0\\) and \\(b &gt; 1\\) be constants, and let \\(f(n)\\) be a driving function defined and nonnegative on all sufficiently large reals. Define \\(T(n)\\) on \\(n \\in \\mathbb{N}\\) by\n\\[\nT(n) = aT(n/b) + f(n)\n\\]\nwhere \\(aT(n/b) = a'T(\\lfloor n/b \\rfloor) + a''T(\\lceil n/b \\rceil)\\) for some \\(a' \\geq 0\\) and \\(a'' \\geq 0\\) satisfying \\(a = a' + a''\\). Then the asymptotic behavior of \\(T(n)\\) can be characterized as follows:\n\nIf there exists \\(\\epsilon &gt; 0\\) such that \\(f(n) = O(n^{\\log_b(a) - \\epsilon})\\), then \\(T(n) = \\Theta(n^{\\log_b(a)})\\)\nIf there exists \\(k \\geq 0\\) such that \\(f(n) = \\Theta(n^{\\log_b(a)}\\log_2^k(n))\\), then \\(T(n) = \\Theta(n^{\\log_b(a)}\\log_2^{k+1}(n))\\).\nIf there exists \\(\\epsilon &gt; 0\\) such that \\(f(n) = \\Omega(n^{\\log_b(a) + \\epsilon})\\), and if \\(f(n)\\) satisfies the regularity condition \\(af(n/b) \\leq cf(n)\\) for some constant \\(c &lt; 1\\) and all sufficiently large \\(n\\), then \\(T(n) = \\Theta(f(n))\\).\n\n\nProof. See Cormen et al. (2001), pg. 107-114.\n\n(← Back to Merge Sort slides)"
  },
  {
    "objectID": "w03/slides.html#references",
    "href": "w03/slides.html#references",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "References",
    "text": "References\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2001. Introduction To Algorithms. MIT Press.\n\n\n\n\n\nDSAN 5500 Week 3: Data Structures, Computational Complexity"
  },
  {
    "objectID": "w03/index.html",
    "href": "w03/index.html",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "",
    "text": "Open slides in new window →",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#data-structure-choice-leftrightarrow-efficiency-for-task",
    "href": "w03/index.html#data-structure-choice-leftrightarrow-efficiency-for-task",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Data Structure Choice \\(\\Leftrightarrow\\) Efficiency for Task",
    "text": "Data Structure Choice \\(\\Leftrightarrow\\) Efficiency for Task\n\nDo we need to be able to insert quickly?\nDo we need to be able to sort quickly?\nDo we need to be able to search quickly?\nAre we searching for individual items or for ranges?",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#recall-primitives",
    "href": "w03/index.html#recall-primitives",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Recall: Primitives",
    "text": "Recall: Primitives\n\nbool\nint\nfloat\nNone\nNow we want to put these together, to form… structures! 👀\nStructures are the things that live in the heap; the stack just points to them",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#tuples",
    "href": "w03/index.html#tuples",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Tuples",
    "text": "Tuples\n\nFixed-size collection of \\(N\\) objects\nUnless otherwise specified, we’re talking about \\(2\\)-tuples\nExample: We can locate something on the Earth by specifying two floats: latitude and longitude!\n\n\n\nCode\ngtown_loc = (38.9076, -77.0723)\ngtown_loc\n\n\n(38.9076, -77.0723)\n\n\n\nBut what if we don’t know in advance how many items we want to store? Ex: how can we store users for a new app?",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#sequences",
    "href": "w03/index.html#sequences",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Sequences",
    "text": "Sequences\n\nIn General: Mapping of integer indices to objects\nx = ['a','b','c']\n\n\\(\\implies\\) x[0] = 'a'\n\\(\\implies\\) x[1] = 'b'\n\\(\\implies\\) x[2] = 'c'\n\nIn Python: list\nNice built-in language constructs for looping over lists, and especially for performing operations on each element",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#looping-over-sequences",
    "href": "w03/index.html#looping-over-sequences",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Looping Over Sequences",
    "text": "Looping Over Sequences\n\n\n\nC/C++/Java:\n\nList&lt;String&gt; myList = Arrays.asList(\"a\", \"b\", \"c\");\nfor (int i = 0; i &lt; x.size(); i++) {\n    System.out.println(myList.get(i));\n}\n\na\nb\nc\n\n\n\nPython:\n\n\n\nCode\nmy_list = ['a','b','c']\nfor list_element in my_list:\n  print(list_element)\n\n\na\nb\nc",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#list-comprehensions-apply-function-to-each-element",
    "href": "w03/index.html#list-comprehensions-apply-function-to-each-element",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "List Comprehensions: Apply Function to Each Element",
    "text": "List Comprehensions: Apply Function to Each Element\n\nConstruct new list by applying operation to each element:\n\n\n\nCode\nmy_nums = [4,5,6,7]\nmy_squares = [num ** 2 for num in my_nums]\nmy_squares\n\n\n[16, 25, 36, 49]\n\n\n\nCan also filter the elements of the list with if:\n\n\n\nCode\nmy_odd_squares = [num ** 2 for num in my_nums if num % 2 == 1]\nmy_odd_squares\n\n\n[25, 49]",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#sets",
    "href": "w03/index.html#sets",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Sets",
    "text": "Sets\n\n\n\nExtremely helpful + efficient for finding unique elements:\n\n\n\nCode\nanimals_i_saw = ['bird','bird','fish','bird','cat','bird','lizard']\nprint(f\"Number of animals I saw: {len(animals_i_saw)}\")\n\n\nNumber of animals I saw: 7\n\n\n\n\nCode\nunique_animals_me = set(animals_i_saw)\nprint(f\"Set of unique animals: {unique_animals_me}\")\nprint(f\"Number of unique animals: {len(unique_animals_me)}\")\n\n\nSet of unique animals: {'lizard', 'fish', 'bird', 'cat'}\nNumber of unique animals: 4\n\n\n\n\nSupports all set operators from math:\n\n\n\nCode\nanimals_you_saw = ['lizard','dog','bird','bird','bird']\nunique_animals_you = set(animals_you_saw)\nunique_animals_both = unique_animals_me.intersection(unique_animals_you)\nprint(f\"Animals we both saw: {unique_animals_both}\")\n\n\nAnimals we both saw: {'lizard', 'bird'}\n\n\n\n\nCode\nunique_animals_either = unique_animals_me.union(unique_animals_you)\nprint(f\"Animals either of us saw: {unique_animals_either}\")\n\n\nAnimals either of us saw: {'lizard', 'fish', 'dog', 'bird', 'cat'}\n\n\n\n\nCode\nunique_animals_meonly = unique_animals_me - unique_animals_you\nprint(f\"Animals I saw that you didn't see: {unique_animals_meonly}\")\nunique_animals_youonly = unique_animals_you - unique_animals_me\nprint(f\"Animals you saw that I didn't see: {unique_animals_youonly}\")\n\n\nAnimals I saw that you didn't see: {'fish', 'cat'}\nAnimals you saw that I didn't see: {'dog'}",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#maps-dictionaries",
    "href": "w03/index.html#maps-dictionaries",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Maps / Dictionaries",
    "text": "Maps / Dictionaries\n\n\n\nWhile other language like Java have lots of fancy types of Map, Python has a single type, the dictionary:\n\n\n\nCode\ngtown_data = {\n  'name': 'Georgetown University',\n  'founded': 1789,\n  'coordinates': (38.9076, -77.0723),\n  'location': {\n    'city': 'Washington',\n    'state': 'DC', # &lt;__&lt;\n    'country': 'USA'\n  }\n}\nprint(gtown_data.keys())\nprint(gtown_data.values())\n\n\ndict_keys(['name', 'founded', 'coordinates', 'location'])\ndict_values(['Georgetown University', 1789, (38.9076, -77.0723), {'city': 'Washington', 'state': 'DC', 'country': 'USA'}])\n\n\n\n\nBe careful when looping! Default behavior is iteration over keys:\n\n\n\nCode\nfor k in gtown_data:\n  print(k)\n\n\nname\nfounded\ncoordinates\nlocation\n\n\n\nFor key-value pairs use .items():\n\n\n\nCode\nfor k, v in gtown_data.items():\n  print(k, v)\n\n\nname Georgetown University\nfounded 1789\ncoordinates (38.9076, -77.0723)\nlocation {'city': 'Washington', 'state': 'DC', 'country': 'USA'}",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#looking-under-the-hood-of-a-data-structure",
    "href": "w03/index.html#looking-under-the-hood-of-a-data-structure",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Looking Under the Hood of a Data Structure",
    "text": "Looking Under the Hood of a Data Structure\n\nLast week we saw the math for why we can “abstract away from” the details of how a particular language works\nWe want to understand these structures independently of the specifics of their implementation in Python (for now)\nSo, let’s construct our own simplified versions of the basic structures, and use these simplified versions to get a sense for their efficiency\n\n(The “true” Python versions may be hyper-optimized, but as we saw, there are fundamental constraints on runtime, assuming \\(P \\neq NP\\))",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#tuples-1",
    "href": "w03/index.html#tuples-1",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Tuples",
    "text": "Tuples\n\n\nCode\nclass MyTuple:\n  def __init__(self, thing1, thing2):\n    self.thing1 = thing1\n    self.thing2 = thing2\n\n  def __repr__(self):\n    return f\"({self.thing1}, {self.thing2})\"\n\n  def __str__(self):\n    return self.__repr__()\n\nt1 = MyTuple('a','b')\nt2 = MyTuple(111, 222)\nprint(t1, t2)\n\n\n(a, b) (111, 222)",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#lists",
    "href": "w03/index.html#lists",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Lists",
    "text": "Lists\n\n\n\nThe list itself just points to a root item:\n\n\n\nCode\nclass MyList:\n  def __init__(self):\n    self.root = None\n\n  def append(self, new_item):\n    if self.root is None:\n      self.root = MyListItem(new_item)\n    else:\n      self.root.append(new_item)\n\n  def __repr__(self):\n    return self.root.__repr__()\n\n\n\n\nAn item has contents, pointer to next item:\n\n\n\nCode\nclass MyListItem:\n  def __init__(self, content):\n    self.content = content\n    self.next = None\n\n  def append(self, new_item):\n    if self.next is None:\n      self.next = MyListItem(new_item)\n    else:\n      self.next.append(new_item)\n\n  def __repr__(self):\n    my_content = self.content\n    return my_content if self.next is None else f\"{my_content}, {self.next.__repr__()}\"\n\n\n\n\n\n\nCode\nusers = MyList()\nusers.append('Jeff')\nusers.append('Alma')\nusers.append('Bo')\nprint(users)\n\n\nJeff, Alma, Bo",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#so-how-many-steps-are-required",
    "href": "w03/index.html#so-how-many-steps-are-required",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "So, How Many “Steps” Are Required…",
    "text": "So, How Many “Steps” Are Required…\n\nTo retrieve the first element in a MyTuple?\nTo retrieve the last element in a MyTuple?\nTo retrieve the first element in a MyList?\nTo retrieve the last element in a MyList?",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#how-many-steps",
    "href": "w03/index.html#how-many-steps",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "How Many Steps?",
    "text": "How Many Steps?\n\n\n\nWith a MyTuple:\n\n\n\nCode\nt1.thing1\n\n\n'a'\n\n\n\n\\(\\implies\\) 1 step\n\n\n\nCode\nt1.thing2\n\n\n'b'\n\n\n\n\\(\\implies\\) 1 step\n\n\n\nWith a MyList:\n\n\n\nCode\nprint(users.root.content)\n\n\nJeff\n\n\n\n\\(\\implies\\) 1 step\n\n\n\nCode\ncurrent_node = users.root\nwhile current_node.next is not None:\n  current_node = current_node.next\nprint(current_node.content)\n\n\nBo\n\n\n\n\\(\\implies\\) (3 steps)\n…But why 3? How many steps if the list contained 5 elements? \\(N\\) elements?",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#pairwise-concatenating-list-elements",
    "href": "w03/index.html#pairwise-concatenating-list-elements",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Pairwise-Concatenating List Elements",
    "text": "Pairwise-Concatenating List Elements\n\nNow rather than just printing, let’s pairwise concatenate:\n\n\n\nCode\ncur_pointer1 = users.root\nwhile cur_pointer1 is not None:\n  cur_pointer2 = users.root\n  while cur_pointer2 is not None:\n    print(cur_pointer1.content + cur_pointer2.content)\n    cur_pointer2 = cur_pointer2.next\n  cur_pointer1 = cur_pointer1.next\n\n\nJeffJeff\nJeffAlma\nJeffBo\nAlmaJeff\nAlmaAlma\nAlmaBo\nBoJeff\nBoAlma\nBoBo\n\n\n\nHow many steps did this take? How about for a list with \\(5\\) elements? \\(N\\) elements?",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#last-example-pairwise-concat-end-check",
    "href": "w03/index.html#last-example-pairwise-concat-end-check",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Last Example: Pairwise-Concat + End Check",
    "text": "Last Example: Pairwise-Concat + End Check\n\n\nCode\nprinted_items = []\ncur_pointer1 = users.root\nwhile cur_pointer1 is not None:\n  cur_pointer2 = users.root\n  while cur_pointer2 is not None:\n    print(cur_pointer1.content + cur_pointer2.content)\n    printed_items.append(cur_pointer1.content)\n    printed_items.append(cur_pointer2.content)\n    cur_pointer2 = cur_pointer2.next\n  cur_pointer1 = cur_pointer1.next\ncheck_pointer = users.root\nwhile check_pointer is not None:\n  if check_pointer.content in printed_items:\n    print(f\"Phew. {check_pointer.content} printed at least once.\")\n  else:\n    print(f\"Oh no! {check_pointer.content} was never printed!!!\")\n  check_pointer = check_pointer.next\n\n\nJeffJeff\nJeffAlma\nJeffBo\nAlmaJeff\nAlmaAlma\nAlmaBo\nBoJeff\nBoAlma\nBoBo\nPhew. Jeff printed at least once.\nPhew. Alma printed at least once.\nPhew. Bo printed at least once.",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#generalizing",
    "href": "w03/index.html#generalizing",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Generalizing",
    "text": "Generalizing\n\nAlgorithms are “efficient” relative to how their runtime scales as the objects grow larger and larger!\nTuple operations take 1 step no matter what\nFor lists, retrieving the first element takes 1 step no matter what, but retrieving the last element takes \\(n\\) steps!\nPairwise concatenation requires \\(n^2\\) steps!",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#the-complexity-of-our-examples",
    "href": "w03/index.html#the-complexity-of-our-examples",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "The Complexity of Our Examples",
    "text": "The Complexity of Our Examples\n\nTuple operations: \\(O(1)\\)\nRetrieving the first element of a list: \\(O(1)\\)\nRetrieving the last element of a list: \\(O(n)\\)\nPairwise concatenation: \\(O(n^2)\\)\nPairwise concatenation+check: \\(O(n^2 + n) = O(n^2) \\leftarrow !!!\\)\nCrucial to think asymptotically to wrap our heads around this!",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#doing-better-than-insertion-sort",
    "href": "w03/index.html#doing-better-than-insertion-sort",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Doing Better Than Insertion Sort",
    "text": "Doing Better Than Insertion Sort\n\nIntuition Break 🥳: Finding a word in a dictionary! dsan.io/dict-lookup",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#how-can-merge-sort-work-that-much-better",
    "href": "w03/index.html#how-can-merge-sort-work-that-much-better",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "How Can Merge Sort Work That Much Better!?",
    "text": "How Can Merge Sort Work That Much Better!?\n\nWith the linear approach, each time we check a word and it’s not our word we eliminate… one measly word 😞\nBut with the divide-and-conquer approach… we eliminate 🔥HALF OF THE REMAINING WORDS🔥",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#merging-two-sorted-lists-in-on-time",
    "href": "w03/index.html#merging-two-sorted-lists-in-on-time",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Merging Two Sorted Lists in \\(O(n)\\) Time",
    "text": "Merging Two Sorted Lists in \\(O(n)\\) Time\n\n\n\n\nFrom Cormen et al. (2001), pg. 37",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#merge-sort-merging-as-subroutine",
    "href": "w03/index.html#merge-sort-merging-as-subroutine",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Merge Sort (Merging as Subroutine)",
    "text": "Merge Sort (Merging as Subroutine)\n\n\n\nFrom Cormen et al. (2001), pg. 40",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#complexity-analysis",
    "href": "w03/index.html#complexity-analysis",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Complexity Analysis",
    "text": "Complexity Analysis\n\nHard way: re-do the line-by-line analysis we did for Insertion-Sort 😣 Easy way: stand on shoulders of giants!\nUsing a famous+fun theorem (the Master Theorem): Given a recurrence \\(T(n) = aT(n/b) + f(n)\\), compute its:\n\nWatershed function \\(W(n) = n^{\\log_b(a)}\\) and\nDriving function \\(D(n) = f(n)\\)\n\nThe Master Theorem gives closed-form asymptotic solution for \\(T(n)\\), split into three cases: (1) \\(W(n)\\) grows faster than \\(D(n)\\), (2) grows at same rate as \\(D(n)\\), or (3) grows slower than \\(D(n)\\)",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#bounding-the-runtime-of-merge-sort",
    "href": "w03/index.html#bounding-the-runtime-of-merge-sort",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Bounding the Runtime of Merge Sort",
    "text": "Bounding the Runtime of Merge Sort\n\nHow about Merge-Sort? \\(T(n) = 2T(n/2) + \\Theta(n)\\)\n\n\\(a = b = 2\\), \\(W(n) = n^{\\log_2(2)} = n\\), \\(D(n) = \\Theta(n)\\)\n\n\\(W(n)\\) and \\(D(n)\\) grow at same rate \\(\\implies\\) Case 21:\n\n\n\n\n\n\n\nApplying the Master Theorem When \\(W(n) = \\Theta(D(n))\\) (Case 2)\n\n\n\n\nIs there a \\(k \\geq 0\\) satisfying \\(D(n) = \\Theta(n^{\\log_b(a)}\\log_2^k(n))\\)?\nIf so, your solution is \\(T(n) = \\Theta(n^{\\log_b(a)}\\log_2^{k+1}(n))\\)\n\n\n\n\nMerge-Sort: \\(k = 0\\) works! \\(\\Theta(n^{\\log_2(2)}\\log_2^0(n)) = \\Theta(n)\\)\nThus \\(T(n) = \\Theta(n^{\\log_b(a)}\\log_2^{k+1}(n)) = \\boxed{\\Theta(n\\log_2n)}\\) 😎",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#breaking-a-problem-into-interacting-parts",
    "href": "w03/index.html#breaking-a-problem-into-interacting-parts",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Breaking a Problem into (Interacting) Parts",
    "text": "Breaking a Problem into (Interacting) Parts\n\nPython so far: “Data science mode”\n\nStart at top of file with raw data\nWrite lines of code until problem solved\n\nPython in this class: “Software engineering mode”\n\nBreak system down into parts\nWrite each part separately\nLink parts together to create the whole\n\n(One implication: .py files may be easier than .ipynb for development!)",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#how-does-a-calculator-work",
    "href": "w03/index.html#how-does-a-calculator-work",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "How Does A Calculator Work?",
    "text": "How Does A Calculator Work?\n\n\n\n(Calculator image from Wikimedia Commons)",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#key-oop-feature-1-encapsulation",
    "href": "w03/index.html#key-oop-feature-1-encapsulation",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Key OOP Feature #1: Encapsulation",
    "text": "Key OOP Feature #1: Encapsulation\n\nImagine you’re on a team trying to make a calculator\nOne person can write the Screen class, another person can write the Button class, and so on\nNatural division of labor! (May seem silly for a calculator, but imagine as your app scales up)",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#key-oop-feature-2-abstraction",
    "href": "w03/index.html#key-oop-feature-2-abstraction",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Key OOP Feature #2: Abstraction",
    "text": "Key OOP Feature #2: Abstraction\n\nAbstraction complements this Encapsulation: the Screen team doesn’t need to know the internal details of Button (just it’s API), and vice-versa\nRelevant data and functions can be “public”, irrelevant internal data and functions “private”\n(Like with type hints), Python doesn’t enforce this distinction, but (unlike with type hints) most libraries do separate public from private by a variable-naming convention…",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#public-protected-private-attributes-in-python",
    "href": "w03/index.html#public-protected-private-attributes-in-python",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Public, Protected, Private Attributes in Python",
    "text": "Public, Protected, Private Attributes in Python\n\n[Public (default)] No underscores: public_var\n[Protected] One underscore: _protected_var\n[Private] Two underscores: __private_var\n\n\n\n\n\nCode\nclass MyTopSecretInfo:\n  __the_info = \"I love Carly Rae Jepsen\"\n\ninfo_obj = MyTopSecretInfo()\ninfo_obj.__the_info\n\n\nAttributeError: 'MyTopSecretInfo' object has no attribute '__the_info'\n\n\nGuess we can’t access it then, right? 😮‍💨\n\n\n\nCode\ninfo_obj._MyTopSecretInfo__the_info\n\n\n'I love Carly Rae Jepsen'\n\n\n\nNOO MY SECRET!!! 😭\nPls don’t tell anyone",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#key-oop-features-3-4-inheritance-polymorphism",
    "href": "w03/index.html#key-oop-features-3-4-inheritance-polymorphism",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Key OOP Features #3-4: Inheritance, Polymorphism",
    "text": "Key OOP Features #3-4: Inheritance, Polymorphism\n\nBetter explained in diagrams than words (next 10 slides!), but we can get a sense by thinking about their etymology:\n“Inheritance” comes from “heir”, like “heir to the throne”\n\nParent passes on [things they possess] to their children\n\n“Polymorphism”: Poly = “many”, Morphe = “forms”\n\nHow does Python know what to do when we print()?\nIt “just works” because print() (through __str__()) takes on many (!) forms (!): each type of object has its own implementation of __str__()",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#use-case-bookstore-inventory-management",
    "href": "w03/index.html#use-case-bookstore-inventory-management",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Use Case: Bookstore Inventory Management",
    "text": "Use Case: Bookstore Inventory Management\n\n\n\nImage source",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#in-pictures",
    "href": "w03/index.html#in-pictures",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "In Pictures",
    "text": "In Pictures\n\n\n\n\n\n\nG\n\nBookstore Relational Diagram\n\n\nBookstore\n\nBookstore\n\nName\n\nLocation\n\nBooklist\n\nGet_Inventory()\n\nSort_Inventory()\n\n\n\nPlace\n\nPlace\n\nCity\n\nState\n\nCountry\n\nPrint_Map()\n\n\n\nBookstore:loc-&gt;Place:placehead\n\n\nHas One\n\n\n\nBook\n\nBook\n\nTitle\n\nAuthors\n\nNum Pages\n\nPreview()\n\n\n\nBookstore:bl-&gt;Book:bookhead\n\n\nHas Multiple\n\n\n\nPerson\n\nPerson\n\nFamily Name\n\nGiven Name\n\n\n\nBook:auths-&gt;Person:personhead\n\n\nHas Multiple",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#creating-classes",
    "href": "w03/index.html#creating-classes",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Creating Classes",
    "text": "Creating Classes\n\nUse case: Creating an inventory system for a Bookstore\n\n\n\n\n\nCode\nclass Bookstore:\n    def __init__(self, name, location):\n        self.name = name\n        self.location = location\n        self.books = []\n\n    def __getitem__(self, index):\n        return self.books[index]\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return f\"Bookstore[{self.get_num_books()} books]\"\n\n    def add_books(self, book_list):\n        self.books.extend(book_list)\n\n    def get_books(self):\n        return self.books\n\n    def get_inventory(self):\n        book_lines = []\n        for book_index, book in enumerate(self.get_books()):\n            cur_book_line = f\"{book_index}. {str(book)}\"\n            book_lines.append(cur_book_line)\n        return \"\\n\".join(book_lines)\n\n    def get_num_books(self):\n        return len(self.get_books())\n\n    def sort_books(self, sort_key):\n        self.books.sort(key=sort_key)\n\nclass Book:\n    def __init__(self, title, authors, num_pages):\n        self.title = title\n        self.authors = authors\n        self.num_pages = num_pages\n\n    def __str__(self):\n        return f\"Book[title={self.get_title()}, authors={self.get_authors()}, pages={self.get_num_pages()}]\"\n\n    def get_authors(self):\n        return self.authors\n\n    def get_first_author(self):\n        return self.authors[0]\n\n    def get_num_pages(self):\n        return self.num_pages\n\n    def get_title(self):\n        return self.title\n\nclass Person:\n    def __init__(self, family_name, given_name):\n        self.family_name = family_name\n        self.given_name = given_name\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return f\"Person[{self.get_family_name()}, {self.get_given_name()}]\"\n\n    def get_family_name(self):\n        return self.family_name\n\n    def get_given_name(self):\n        return self.given_name\n\n\n\n\n\nCode\nmy_bookstore = Bookstore(\"Bookland\", \"Washington, DC\")\nplath = Person(\"Plath\", \"Sylvia\")\nbell_jar = Book(\"The Bell Jar\", [plath], 244)\nmarx = Person(\"Marx\", \"Karl\")\nengels = Person(\"Engels\", \"Friedrich\")\nmanifesto = Book(\"The Communist Manifesto\", [marx, engels], 43)\nelster = Person(\"Elster\", \"Jon\")\ncement = Book(\"The Cement of Society\", [elster], 311)\nmy_bookstore.add_books([bell_jar, manifesto, cement])\nprint(my_bookstore)\nprint(my_bookstore[0])\nprint(\"Inventory:\")\nprint(my_bookstore.get_inventory())\n\n\nBookstore[3 books]\nBook[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\nInventory:\n0. Book[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\n1. Book[title=The Communist Manifesto, authors=[Person[Marx, Karl], Person[Engels, Friedrich]], pages=43]\n2. Book[title=The Cement of Society, authors=[Person[Elster, Jon]], pages=311]",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#doing-things-with-classes",
    "href": "w03/index.html#doing-things-with-classes",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Doing Things With Classes",
    "text": "Doing Things With Classes\n\nNow we can use our OOP structure, for example to sort the inventory in different ways!\n\n\n\n\nAlphabetical (By First Author)\n\n\n\nCode\nsort_alpha = lambda x: x.get_first_author().get_family_name()\nmy_bookstore.sort_books(sort_key = sort_alpha)\nprint(my_bookstore.get_inventory())\n\n\n0. Book[title=The Cement of Society, authors=[Person[Elster, Jon]], pages=311]\n1. Book[title=The Communist Manifesto, authors=[Person[Marx, Karl], Person[Engels, Friedrich]], pages=43]\n2. Book[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\n\n\n\n\nBy Page Count\n\n\n\nCode\nsort_pages = lambda x: x.get_num_pages()\nmy_bookstore.sort_books(sort_key = sort_pages)\nprint(my_bookstore.get_inventory())\n\n\n0. Book[title=The Communist Manifesto, authors=[Person[Marx, Karl], Person[Engels, Friedrich]], pages=43]\n1. Book[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\n2. Book[title=The Cement of Society, authors=[Person[Elster, Jon]], pages=311]",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#inheritance-and-polymorphism",
    "href": "w03/index.html#inheritance-and-polymorphism",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Inheritance and Polymorphism",
    "text": "Inheritance and Polymorphism\n\nEncapsulate general properties in parent class, specific properties in child classes\n\n\n\n\n(You can edit this or make your own UML diagrams in nomnoml!)",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#or-is-this-better",
    "href": "w03/index.html#or-is-this-better",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Or… Is This Better?",
    "text": "Or… Is This Better?\n\n\n\nEdit in nomnoml",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#design-choices",
    "href": "w03/index.html#design-choices",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Design Choices",
    "text": "Design Choices\n\nThe goal is to encapsulate as best as possible: which objects should have which properties, and which methods?\nExample: Fiction vs. Non-Fiction. How important is this distinction for your use case?\n\n\n\n\nOption 1: As Property of Book\n\n\n\nCode\nfrom enum import Enum\nclass BookType(Enum):\n    NONFICTION = 0\n    FICTION = 1\n\nclass Book:\n    def __init__(self, title: str, authors: list[Person], num_pages: int, type: BookType):\n        self.title = title\n        self.authors = authors\n        self.num_pages = num_pages\n        self.type = type\n\n    def __str__(self):\n        return f\"Book[title={self.title}, authors={self.authors}, pages={self.num_pages}, type={self.type}]\"\n\n\n\n\nCode\njoyce = Person(\"Joyce\", \"James\")\nulysses = Book(\"Ulysses\", [joyce], 732, BookType.FICTION)\nschelling = Person(\"Schelling\", \"Thomas\")\nmicromotives = Book(\"Micromotives and Macrobehavior\", [schelling], 252, BookType.NONFICTION)\nprint(ulysses)\nprint(micromotives)\n\n\nBook[title=Ulysses, authors=[Person[Joyce, James]], pages=732, type=BookType.FICTION]\nBook[title=Micromotives and Macrobehavior, authors=[Person[Schelling, Thomas]], pages=252, type=BookType.NONFICTION]\n\n\n\n\nOption 2: Separate Classes\n\n\n\nCode\n# class Book defined as earlier\nclass FictionBook(Book):\n    def __init__(self, title, authors, num_pages, characters):\n        super().__init__(title, authors, num_pages)\n        self.characters = characters\n\nclass NonfictionBook(Book):\n    def __init__(self, title, authors, num_pages, topic):\n        super().__init__(title, authors, num_pages)\n        self.topic = topic\n\n\n\n\nCode\njoyce = Person(\"Joyce\", \"James\")\nulysses = FictionBook(\"Ulysses\", [joyce], 732, [\"Daedalus\"])\nschelling = Person(\"Schelling\", \"Thomas\")\nmicromotives = NonfictionBook(\"Micromotives and Macrobehavior\", [schelling], 252, \"Economics\")\nprint(ulysses)\nprint(micromotives)\n\n\nBook[title=Ulysses, authors=[Person[Joyce, James]], pages=732]\nBook[title=Micromotives and Macrobehavior, authors=[Person[Schelling, Thomas]], pages=252]",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#appendix-the-full-master-theorem",
    "href": "w03/index.html#appendix-the-full-master-theorem",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Appendix: The Full Master Theorem",
    "text": "Appendix: The Full Master Theorem\nMaster Theorem: Let \\(a &gt; 0\\) and \\(b &gt; 1\\) be constants, and let \\(f(n)\\) be a driving function defined and nonnegative on all sufficiently large reals. Define \\(T(n)\\) on \\(n \\in \\mathbb{N}\\) by\n\\[\nT(n) = aT(n/b) + f(n)\n\\]\nwhere \\(aT(n/b) = a'T(\\lfloor n/b \\rfloor) + a''T(\\lceil n/b \\rceil)\\) for some \\(a' \\geq 0\\) and \\(a'' \\geq 0\\) satisfying \\(a = a' + a''\\). Then the asymptotic behavior of \\(T(n)\\) can be characterized as follows:\n\nIf there exists \\(\\epsilon &gt; 0\\) such that \\(f(n) = O(n^{\\log_b(a) - \\epsilon})\\), then \\(T(n) = \\Theta(n^{\\log_b(a)})\\)\nIf there exists \\(k \\geq 0\\) such that \\(f(n) = \\Theta(n^{\\log_b(a)}\\log_2^k(n))\\), then \\(T(n) = \\Theta(n^{\\log_b(a)}\\log_2^{k+1}(n))\\).\nIf there exists \\(\\epsilon &gt; 0\\) such that \\(f(n) = \\Omega(n^{\\log_b(a) + \\epsilon})\\), and if \\(f(n)\\) satisfies the regularity condition \\(af(n/b) \\leq cf(n)\\) for some constant \\(c &lt; 1\\) and all sufficiently large \\(n\\), then \\(T(n) = \\Theta(f(n))\\).\n\n\nProof. See Cormen et al. (2001), pg. 107-114.\n\n(← Back to Merge Sort slides)",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#references",
    "href": "w03/index.html#references",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "References",
    "text": "References\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2001. Introduction To Algorithms. MIT Press.",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w03/index.html#footnotes",
    "href": "w03/index.html#footnotes",
    "title": "Week 3: Data Structures and Computational Complexity",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee appendix slide for all 3 cases, if you’re some kind of masochist↩︎",
    "crumbs": [
      "Week 3: Jan 29"
    ]
  },
  {
    "objectID": "w04/index.html",
    "href": "w04/index.html",
    "title": "Week 4: Heaps, Stacks, Trees, Graphs",
    "section": "",
    "text": "Open slides in new window →",
    "crumbs": [
      "Week 4: Feb 5"
    ]
  },
  {
    "objectID": "w02/index.html",
    "href": "w02/index.html",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "",
    "text": "Open slides in new window →",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#why-does-the-nyc-subway-have-express-lines",
    "href": "w02/index.html#why-does-the-nyc-subway-have-express-lines",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Why Does The NYC Subway Have Express Lines?",
    "text": "Why Does The NYC Subway Have Express Lines?\n\n\n\nFrom NYC Central Park website",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#why-stop-at-two-levels",
    "href": "w02/index.html#why-stop-at-two-levels",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Why Stop At Two Levels?",
    "text": "Why Stop At Two Levels?\n\n\n\nFrom Skip List Data Structure Explained, Sumit’s Diary blog",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#how-tf-does-google-maps-work",
    "href": "w02/index.html#how-tf-does-google-maps-work",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "How TF Does Google Maps Work?",
    "text": "How TF Does Google Maps Work?\n\nA (mostly) full-on answer: soon to come! Data structures for spatial data\nA step in that direction: Quadtrees! (Fractal DC)\n\n\nJim Kang’s Quadtree Visualizations",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#the-secretly-exciting-world-of-matrix-multiplication",
    "href": "w02/index.html#the-secretly-exciting-world-of-matrix-multiplication",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "The Secretly Exciting World of Matrix Multiplication",
    "text": "The Secretly Exciting World of Matrix Multiplication\n\nFun Fact 1: Most of modern Machine Learning is, at the processor level, just a bunch of matrix operations\nFun Fact 2: The way we’ve all learned how to multiply matrices requires \\(O(N^3)\\) operations, for two \\(N \\times N\\) matrices \\(A\\) and \\(B\\)\nFun Fact 3: \\(\\underbrace{x^2 - y^2}_{\\mathclap{\\times\\text{ twice, }\\pm\\text{ once}}} = \\underbrace{(x+y)(x-y)}_{\\times\\text{once, }\\pm\\text{ twice}}\\)\nFun Fact 4: These are not very fun facts at all",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#why-is-jeff-rambling-about-matrix-math-from-300-years-ago",
    "href": "w02/index.html#why-is-jeff-rambling-about-matrix-math-from-300-years-ago",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Why Is Jeff Rambling About Matrix Math From 300 Years Ago?",
    "text": "Why Is Jeff Rambling About Matrix Math From 300 Years Ago?\n\nThe way we all learned it in school (for \\(N = 2\\)):\n\n\\[\nAB = \\begin{bmatrix}\na_{11} & a_{12} \\\\\na_{21} & a_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\nb_{11} & b_{12} \\\\\nb_{21} & b_{22}\n\\end{bmatrix} =\n\\begin{bmatrix}\na_{11}b_{11} + a_{12}b_{21} & a_{11}b_{12} + a_{12}b_{22} \\\\\na_{21}b_{11} + a_{22}b_{21} & a_{21}b_{12} + a_{22}b_{22}\n\\end{bmatrix}\n\\]\n\n12 operations: 8 multiplications, 4 additions \\(\\implies O(N^3) = O(2^3) = O(8)\\)\nAre we trapped? Like… what is there to do besides performing these \\(N^3\\) operations, if we want to multiply two \\(N \\times N\\) matrices? Why are we about to move onto yet another slide about this?",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#block-partitioning-matrices",
    "href": "w02/index.html#block-partitioning-matrices",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Block-Partitioning Matrices",
    "text": "Block-Partitioning Matrices\n\nNow let’s consider big matrices, whose dimensions are a power of 2 (for ease of illustration): \\(A\\) and \\(B\\) are now \\(N \\times N = 2^n \\times 2^n\\) matrices\nWe can “decompose” the matrix product \\(AB\\) as:\n\n\\[\nAB = \\begin{bmatrix}\nA_{11} & A_{12} \\\\\nA_{21} & A_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\nB_{11} & B_{12} \\\\\nB_{21} & B_{22}\n\\end{bmatrix} =\n\\begin{bmatrix}\nA_{11}B_{11} + A_{12}B_{21} & A_{11}B_{12} + A_{12}B_{22} \\\\\nA_{21}B_{11} + A_{22}B_{21} & A_{21}B_{12} + A_{22}B_{22}\n\\end{bmatrix}\n\\]\n\nWhich gives us a recurrence relation representing the total number of computations required for this big-matrix multiplication: \\(T(N) = \\underbrace{8T(N/2)}_{\\text{Multiplications}} + \\underbrace{\\Theta(1)}_{\\text{Additions}}\\)\nIt turns out that (using a method we’ll learn in Week 3), given this recurrence relation and our base case from the previous slide, this divide-and-conquer approach via block-partitioning doesn’t help us: we still get \\(T(n) = O(n^3)\\)…\nSo why is Jeff still torturing us with this example?",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#time-for-some-matrix-magic",
    "href": "w02/index.html#time-for-some-matrix-magic",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Time For Some 🪄MATRIX MAGIC!🪄",
    "text": "Time For Some 🪄MATRIX MAGIC!🪄\n\n\nIf we define\n\n\\[\n\\begin{align*}\nm_1 &= (a_{11}+a_{22})(b_{11}+b_{22}) \\\\\nm_2 &= (a_{21}+a_{22})b_{11} \\\\\nm_3 &= a_{11}(b_{12}-b_{22}) \\\\\nm_4 &= a_{22}(b_{21}-b_{11}) \\\\\nm_5 &= (a_{11}+a_{12})b_{22} \\\\\nm_6 &= (a_{21}-a_{11})(b_{11}+b_{12}) \\\\\nm_7 &= (a_{12}-a_{22})(b_{21}+b_{22})\n\\end{align*}\n\\]\n\n\n\nThen we can combine these seven scalar products to obtain our matrix product:\n\n\\[\nAB = \\begin{bmatrix}\nm_1 + m_4 - m_5 + m_7 & m_3 + m_5 \\\\\nm_2 + m_4 & m_1 - m_2 + m_3 + m_6\n\\end{bmatrix}\n\\]\n\n\nTotal operations: 7 multiplications, 18 additions",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#block-partitioned-matrix-magic",
    "href": "w02/index.html#block-partitioned-matrix-magic",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Block-Partitioned Matrix Magic",
    "text": "Block-Partitioned Matrix Magic\n\nUsing the previous slide as our base case and applying this same method to the block-paritioned big matrices, we get the same result, but where the four entries in \\(AB\\) here are now matrices rather than scalars:\n\n\\[\nAB = \\begin{bmatrix}\nM_1 + M_4 - M_5 + M_7 & M_3 + M_5 \\\\\nM_2 + M_4 & M_1 - M_2 + M_3 + M_6\n\\end{bmatrix}\n\\]\n\nWe now have a different recurrence relation: \\(T(N) = \\underbrace{7T(N/2)}_{\\text{Multiplications}} + \\underbrace{\\Theta(N^2)}_{\\text{Additions}}\\)\nAnd it turns out, somewhat miraculously, that the additional time required for the increased number of additions is significantly less than the time savings we obtain by doing 7 instead of 8 multiplications, since this method now runs in \\(T(N) = O(N^{\\log_2(7)}) \\approx O(N^{2.807}) &lt; O(N^3)\\) 🤯",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#insertion-sort",
    "href": "w02/index.html#insertion-sort",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Insertion Sort",
    "text": "Insertion Sort\n\nThink of how you might sort a deck of cards in your hand",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#cards-rightarrow-list-elements",
    "href": "w02/index.html#cards-rightarrow-list-elements",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Cards \\(\\rightarrow\\) List Elements",
    "text": "Cards \\(\\rightarrow\\) List Elements\n\nInput list: [5, 2, 4, 6, 1, 3]\n\n\n\n\n\n\n\nNotice how, at each point:\n\nThere is a card we’re currently “looking at”, called the key, and\nThere is an invariant: everything in the list before the key is already sorted",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#complexity-analysis",
    "href": "w02/index.html#complexity-analysis",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Complexity Analysis",
    "text": "Complexity Analysis\n\nLet \\(t_i\\) be the number of times the while loop runs, \\(\\widetilde{n} = n - 1\\):\n\n\n\n\n\nCode\nCost\nTimes Run\n\n\n\n\n1\nfor i = 1 to n-1:\n\\(c_1\\)\n\\(\\widetilde{n}\\)\n\n\n2\n  key = A[i]\n\\(c_2\\)\n\\(\\widetilde{n}\\)\n\n\n3\n  # Insert A[i] into sorted subarray A[0:i-1]\n\\(0\\)\n\\(\\widetilde{n}\\)\n\n\n4\n  j = i - 1\n\\(c_4\\)\n\\(\\widetilde{n}\\)\n\n\n5\n  while j &gt;= 0 and A[j] &gt; key:\n\\(c_5\\)\n\\(\\sum_{i=2}^n t_i\\)\n\n\n6\n    A[j + 1] = A[j]\n\\(c_6\\)\n\\(\\sum_{i=2}^n(t_i - 1)\\)\n\n\n7\n    j = j - 1\n\\(c_7\\)\n\\(\\sum_{i=2}^n(t_i - 1)\\)\n\n\n8\n  A[j + 1] = key\n\\(c_8\\)\n\\(\\widetilde{n}\\)\n\n\n\n\\[\nT(n) = c_1\\widetilde{n} + c_2\\widetilde{n} + c_4\\widetilde{n} + c_5\\sum_{i=2}^nt_i + c_6\\sum_{i=2}^n(t_i - 1) + c_7\\sum_{i=2}^n(t_i-1) + c_8\\widetilde{n}\n\\]",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#simplifying",
    "href": "w02/index.html#simplifying",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Simplifying",
    "text": "Simplifying\n\nThe original, scary-looking equation:\n\n\\[\nT(n) = c_1n + c_2\\widetilde{n} + c_4\\widetilde{n} + c_5{\\color{orange}\\boxed{\\color{black}\\sum_{i=2}^nt_i}} + c_6{\\color{lightblue}\\boxed{\\color{black}\\sum_{i=2}^n(t_i - 1)}} + c_7{\\color{lightblue}\\boxed{\\color{black}\\sum_{i=2}^n(t_i-1)}} + c_8\\widetilde{n}\n\\]\n\nBut \\(\\sum_{i=1}^ni = \\frac{n(n+1)}{2}\\), so:\n\n\\[\n\\begin{align*}\n{\\color{orange}\\boxed{\\color{black}\\sum_{i=2}^ni}} &= \\sum_{i=1}^ni - \\sum_{i=1}^1i = \\frac{n(n+1)}{2} - 1 \\\\\n{\\color{lightblue}\\boxed{\\color{black}\\sum_{i=2}^n(i-1)}} &= \\sum_{i=1}^{n-1}i = \\frac{(n-1)(n-1+1)}{2} = \\frac{n(n-1)}{2}\n\\end{align*}\n\\]\n\nAnd the scary-looking equation simplifies to\n\n\\[\n\\begin{align*}\nT(n) = &{\\color{gray}\\left(\\frac{c_5}{2} + \\frac{c_6}{2} + \\frac{c_7}{2}\\right)}{\\color{green}n^2} + {\\color{gray}\\left(c_1 + c_2 + c_4 + \\frac{c_5}{2} - \\frac{c_6}{2} - \\frac{c_7}{2} + c_8\\right)}{\\color{green}n^1} \\\\\n\\phantom{T(n) = }& - {\\color{gray}(c_2 + c_4 + c_5 + c_8)}{\\color{green}n^0}\n\\end{align*}\n\\]",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#remember-asymptotic-analysis",
    "href": "w02/index.html#remember-asymptotic-analysis",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Remember: Asymptotic Analysis!",
    "text": "Remember: Asymptotic Analysis!\n\nIt still looks pretty messy, but remember: we care about efficiency as a function of \\(n\\)!\n\n\\[\n\\begin{align*}\nT(n) = &\\underbrace{{\\color{gray}\\left(\\frac{c_5}{2} + \\frac{c_6}{2} + \\frac{c_7}{2}\\right)}}_{\\text{Constant}}\\underbrace{\\phantom{(}{\\color{green}n^2}\\phantom{)}}_{\\text{Quadratic}} \\\\\n\\phantom{T(n) = }&+ \\underbrace{{\\color{gray}\\left(c_1 + c_2 + c_4 + \\frac{c_5}{2} - \\frac{c_6}{2} - \\frac{c_7}{2} + c_8\\right)}}_{\\text{Constant}}\\underbrace{\\phantom{(}{\\color{green}n^1}\\phantom{)}}_{\\text{Linear}} \\\\\n\\phantom{T(n) = }& - \\underbrace{{\\color{gray}(c_2 + c_4 + c_5 + c_8)}}_{\\text{Constant}}\\underbrace{{\\color{green}n^0}}_{\\text{Constant}}\n\\end{align*}\n\\]\n\nSo, there’s a sense in which \\(T(n) \\approx n^2\\), for “sufficiently large” values of \\(n\\)…\nLet’s work our way towards formalizing the \\(\\approx\\)!",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#the-figure-you-should-make-in-your-brain-every-time",
    "href": "w02/index.html#the-figure-you-should-make-in-your-brain-every-time",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "The Figure You Should Make In Your Brain Every Time",
    "text": "The Figure You Should Make In Your Brain Every Time\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nn_vals = [np.power(10, k) for k in np.arange(1, 2.75, 0.25)]\nruntime_df = pd.DataFrame({'$n$': n_vals})\nruntime_df['$n^2 + 50n$'] = runtime_df['$n$'].apply(lambda x: np.power(x, 2) + 50*x)\nruntime_df['$n^2 + 10000$'] = runtime_df['$n$'].apply(lambda x: np.power(x, 2) + 10000)\nruntime_df['$O(n)$'] = runtime_df['$n$'].copy()\nruntime_df['$O(nlogn)$'] = runtime_df['$n$'].apply(lambda x: x * np.log(x))\nruntime_df['$O(n^2)$'] = runtime_df['$n$'].apply(lambda x: np.power(x, 2))\nruntime_df['$O(n^2logn)$'] = runtime_df['$n$'].apply(lambda x: np.power(x,2) * np.log(x))\nruntime_df['$O(n^3)$'] = runtime_df['$n$'].apply(lambda x: np.power(x, 3))\nruntime_df['$O(n^3logn)$'] = runtime_df['$n$'].apply(lambda x: np.power(x, 3) * np.log(x))\n# Get the max values, for labeling the ends of lines\nmax_vals = runtime_df.max().to_dict()\nplot_df = runtime_df.melt(id_vars=['$n$'])\n#print(plot_df)\nstyle_map = {col: '' if (col == '$n^2 + 50n$') or (col == '$n^2 + 10000$') else (2,1) for col in runtime_df.columns}\nfig, ax = plt.subplots(figsize=(11,5))\nsns.lineplot(plot_df, x='$n$', y='value', hue='variable', style='variable', dashes=style_map)\n#plt.xscale('log')\nplt.yscale('log')\n# extract the existing handles and labels\nh, l = ax.get_legend_handles_labels()\n# slice the appropriate section of l and h to include in the legend\nax.legend(h[0:2], l[0:2])\nfor label, val in max_vals.items():\n  if (label == '$n$') or (label == '$n^2 + 50n$') or (label == '$n^2 + 10000$'):\n    continue\n  if 'logn' in label:\n    label = label.replace('logn', r'\\log(n)')\n  ax.text(x = max_vals['$n$'] + 2, y = val, s=label, va='center')\n# Hide the right and top spines\nax.spines[['right', 'top']].set_visible(False)\nplt.show()\n\n\n\n\n\n\n\n\n\n\nTakeaway: As \\(n \\rightarrow \\infty\\), highest-degree terms dominate!",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#constants-on-highest-degree-terms-also-go-away",
    "href": "w02/index.html#constants-on-highest-degree-terms-also-go-away",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Constants On Highest-Degree Terms Also Go Away",
    "text": "Constants On Highest-Degree Terms Also Go Away\n\n(Though this is harder to see, without a log-log plot:)\n\n\n\nCode\nn_vals = [np.power(10, k) for k in np.arange(1, 6, 0.5)]\nrt_const_df = pd.DataFrame({'$n$': n_vals})\nrt_const_df['$20n^2$'] = rt_const_df['$n$'].apply(lambda x: 20*np.power(x,2))\nrt_const_df['$n^2$'] = rt_const_df['$n$'].apply(lambda x: np.power(x,2))\nrt_const_df['$n^2logn$'] = rt_const_df['$n$'].apply(lambda x: np.power(x,2) * np.power(np.log(x),2))\nrt_const_df['$n^3$'] = rt_const_df['$n$'].apply(lambda x: np.power(x,3))\n# Get the max values, for labeling the ends of lines\nmax_vals = rt_const_df.max().to_dict()\nplot_df_const = rt_const_df.melt(id_vars=['$n$'])\nstyle_map = {col: '' if (col == '$20n^2$') else (2,1) for col in rt_const_df.columns}\nfig_const, ax_const = plt.subplots(figsize=(11,5))\nsns.lineplot(plot_df_const, x='$n$', y='value', hue='variable', style='variable', dashes=style_map)\nplt.xscale('log')\nplt.yscale('log')\n# extract the existing handles and labels\nh_const, l_const = ax_const.get_legend_handles_labels()\n# slice the appropriate section of l and h to include in the legend\nax_const.legend(h_const[0:1], l_const[0:1])\nfor label, val in max_vals.items():\n  if (label == '$n$') or (label == '$20n^2$'):\n    continue\n  if 'logn' in label:\n    label = label.replace('logn', r'\\log(n)')\n  ax_const.text(x = max_vals['$n$'] + 10**4, y = val, s=label, va='center')\n# Hide the right and top spines\nax_const.spines[['right', 'top']].set_visible(False)\nplt.show()",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#formalizing-big-o-notation",
    "href": "w02/index.html#formalizing-big-o-notation",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Formalizing Big-O Notation",
    "text": "Formalizing Big-O Notation\n\nLet \\(f, g: \\mathbb{N} \\rightarrow \\mathbb{N}\\). Then we write \\(f(n) = O(g(n))\\) when there exists a threshold \\(n_0 &gt; 0\\) and a constant \\(K &gt; 0\\) such that \\[\n\\forall n \\geq n_0 \\left[ f(n) \\leq K\\cdot g(n) \\right]\n\\]\nIn words: beyond a certain point \\(n_0\\), \\(f(n)\\) is bounded above by \\(K\\cdot g(n)\\).\nDefinition from Savage (1998, pg. 13)",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#intuition-rightarrow-proof",
    "href": "w02/index.html#intuition-rightarrow-proof",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Intuition \\(\\rightarrow\\) Proof",
    "text": "Intuition \\(\\rightarrow\\) Proof\n\nUsing this definition, we can now prove \\(f(n) = n^2 + 50n = O(n^2)\\)!\nHere \\(f(n) = n^2 + 50n\\), \\(g(n) = n^2\\)\nTheorem: \\(\\exists \\; n_0 \\; \\text{ s.t. } \\forall n \\geq n_0 \\left[ n^2 + 50n \\leq Kn^2 \\right]\\)\nProof: Let \\(K = 50\\). Then \\[\n\\begin{align*}\n&n^2 + 50n \\leq 50n^2 \\iff n + 50 \\leq 50n \\\\\n&\\iff 49n \\geq 50 \\iff n \\geq \\frac{50}{49}.\n\\end{align*}\n\\]\nSo if we choose \\(n_0 = 2\\), the chain of statements holds. \\(\\blacksquare\\)",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#bounding-insertion-sort-runtime",
    "href": "w02/index.html#bounding-insertion-sort-runtime",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Bounding Insertion Sort Runtime",
    "text": "Bounding Insertion Sort Runtime\n\nRuns in \\(T(n) = O(n^2)\\) (use constants from prev slide)\nCan similarly define lower bound \\(T(n) = \\Omega(f(n))\\)\n\n\\(O\\) = “Big-Oh”, \\(\\Omega\\) = “Big-Omega”\n\nNeed to be careful with \\(O(f(n))\\) vs. \\(\\Omega(f(n))\\) however: difference between “for all inputs” vs. “for some inputs”:\n\n\n\n\n\n\n\nBounding Worst-Case Runtime\n\n\n\nBy saying that the worst-case running time of an algorithm is \\(\\Omega(n^2)\\), we mean that for every input size \\(n\\) above a certain threshold, there is at least one input of size \\(n\\) for which the algorithm takes at least \\(cn^2\\) time, for some positive constant \\(n\\). It does not necessarily mean that the algorithm takes at least \\(cn^2\\) time for all inputs.",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#intuition-for-lower-bound",
    "href": "w02/index.html#intuition-for-lower-bound",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Intuition for Lower Bound",
    "text": "Intuition for Lower Bound\n\nSpoiler: Insertion sort also runs in \\(T(n) = \\Omega(n^2)\\) time. How could we prove this?\nGiven any value \\(n &gt; n_0\\), we need to construct an input for which Insertion-Sort requires \\(cn^2\\) steps: consider a list where \\(n/3\\) greatest values are in first \\(n/3\\) slots:\n\n\n\n\nAll \\(n/3\\) values in \\(\\textrm{L}\\) pass, one-by-one, through the \\(n/3\\) slots in \\(\\textrm{M}\\) (since they must end up in \\(\\textrm{R}\\)) \\(\\implies (n/3)(n/3) = n^2/9 = \\Omega(n^2)\\) steps!\n\n\n\nFinal definition (a theorem you could prove if you want!): \\(\\Theta\\) = “Big-Theta”\n\nIf \\(T(n) = \\overline{O}(g(n))\\) and \\(T(n) = \\Omega(g(n))\\), then \\(T(n) = \\Theta(n)\\)\n\n\\(\\implies\\) most “informative” way to characterize insertion sort is \\(\\boxed{T(n) = \\Theta(n^2)}\\)",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#doing-better-than-insertion-sort",
    "href": "w02/index.html#doing-better-than-insertion-sort",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Doing Better Than Insertion Sort",
    "text": "Doing Better Than Insertion Sort\n\nIntuition Break 🥳: Finding a word in a dictionary! dsan.io/dict-lookup",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#how-can-merge-sort-work-that-much-better",
    "href": "w02/index.html#how-can-merge-sort-work-that-much-better",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "How Can Merge Sort Work That Much Better!?",
    "text": "How Can Merge Sort Work That Much Better!?\n\nWith the linear approach, each time we check a word and it’s not our word we eliminate… one measly word 😞\nBut with the divide-and-conquer approach… we eliminate 🔥HALF OF THE REMAINING WORDS🔥",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#merging-two-sorted-lists-in-on-time",
    "href": "w02/index.html#merging-two-sorted-lists-in-on-time",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Merging Two Sorted Lists in \\(O(n)\\) Time",
    "text": "Merging Two Sorted Lists in \\(O(n)\\) Time\n\n\n\nFrom Cormen et al. (2001), pg. 37",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#merge-sort-merging-as-subroutine",
    "href": "w02/index.html#merge-sort-merging-as-subroutine",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Merge Sort (Merging as Subroutine)",
    "text": "Merge Sort (Merging as Subroutine)\n\n\n\nFrom Cormen et al. (2001), pg. 40",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#complexity-analysis-1",
    "href": "w02/index.html#complexity-analysis-1",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Complexity Analysis",
    "text": "Complexity Analysis\n\nHard way: re-do the line-by-line analysis we did for Insertion-Sort 😣 Easy way: stand on shoulders of giants!\nUsing a famous+fun theorem (the Master Theorem): Given a recurrence \\(T(n) = aT(n/b) + f(n)\\), compute its:\n\nWatershed function \\(W(n) = n^{\\log_b(a)}\\) and\nDriving function \\(D(n) = f(n)\\)\n\nThe Master Theorem gives closed-form asymptotic solution for \\(T(n)\\), split into three cases:\n(1) \\(W(n)\\) grows faster than \\(D(n)\\), (2) grows at same rate as \\(D(n)\\), or (3) grows slower than \\(D(n)\\)",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#bounding-the-runtime-of-merge-sort",
    "href": "w02/index.html#bounding-the-runtime-of-merge-sort",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Bounding the Runtime of Merge Sort",
    "text": "Bounding the Runtime of Merge Sort\n\nHow about Merge-Sort? \\(T(n) = 2T(n/2) + \\Theta(n)\\)\n\n\\(a = b = 2\\), \\(W(n) = n^{\\log_2(2)} = n\\), \\(D(n) = \\Theta(n)\\)\n\n\\(W(n)\\) and \\(D(n)\\) grow at same rate \\(\\implies\\) Case 21:\n\n\n\n\n\n\n\nApplying the Master Theorem When \\(W(n) = \\Theta(D(n))\\) (Case 2)\n\n\n\n\nIs there a \\(k \\geq 0\\) satisfying \\(D(n) = \\Theta(n^{\\log_b(a)}\\log_2^k(n))\\)?\nIf so, your solution is \\(T(n) = \\Theta(n^{\\log_b(a)}\\log_2^{k+1}(n))\\)\n\n\n\n\nMerge-Sort: \\(k = 0\\) works! \\(\\Theta(n^{\\log_2(2)}\\log_2^0(n)) = \\Theta(n)\\)\nThus \\(T(n) = \\Theta(n^{\\log_b(a)}\\log_2^{k+1}(n)) = \\boxed{\\Theta(n\\log_2n)}\\) 😎",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#breaking-a-problem-into-interacting-parts",
    "href": "w02/index.html#breaking-a-problem-into-interacting-parts",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Breaking a Problem into (Interacting) Parts",
    "text": "Breaking a Problem into (Interacting) Parts\n\nPython so far: “Data science mode”\n\nStart at top of file with raw data\nWrite lines of code until problem solved\n\nPython in this class: “Software engineering mode”\n\nBreak system down into parts\nWrite each part separately\nLink parts together to create the whole\n\n(One implication: .py files may be easier than .ipynb for development!)",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#how-does-a-calculator-work",
    "href": "w02/index.html#how-does-a-calculator-work",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "How Does A Calculator Work?",
    "text": "How Does A Calculator Work?\n\n\n\n(Calculator image from Wikimedia Commons)",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#key-oop-feature-1-encapsulation",
    "href": "w02/index.html#key-oop-feature-1-encapsulation",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Key OOP Feature #1: Encapsulation",
    "text": "Key OOP Feature #1: Encapsulation\n\nImagine you’re on a team trying to make a calculator\nOne person can write the Screen class, another person can write the Button class, and so on\nNatural division of labor! (May seem silly for a calculator, but imagine as your app scales up)",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#use-case-bookstore-inventory-management",
    "href": "w02/index.html#use-case-bookstore-inventory-management",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Use Case: Bookstore Inventory Management",
    "text": "Use Case: Bookstore Inventory Management\n\n\n\nImage source",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#in-pictures",
    "href": "w02/index.html#in-pictures",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "In Pictures",
    "text": "In Pictures\n\n\n\n\n\n\nG\n\nBookstore Relational Diagram\n\n\nBookstore\n\nBookstore\n\nName\n\nLocation\n\nBooklist\n\nGet_Inventory()\n\nSort_Inventory()\n\n\n\nPlace\n\nPlace\n\nCity\n\nState\n\nCountry\n\nPrint_Map()\n\n\n\nBookstore:loc-&gt;Place:placehead\n\n\nHas One\n\n\n\nBook\n\nBook\n\nTitle\n\nAuthors\n\nNum Pages\n\nPreview()\n\n\n\nBookstore:bl-&gt;Book:bookhead\n\n\nHas Multiple\n\n\n\nPerson\n\nPerson\n\nFamily Name\n\nGiven Name\n\n\n\nBook:auths-&gt;Person:personhead\n\n\nHas Multiple",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#creating-classes",
    "href": "w02/index.html#creating-classes",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Creating Classes",
    "text": "Creating Classes\n\nUse case: Creating an inventory system for a Bookstore\n\n\n\n\n\nCode\nclass Bookstore:\n    def __init__(self, name, location):\n        self.name = name\n        self.location = location\n        self.books = []\n\n    def __getitem__(self, index):\n        return self.books[index]\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return f\"Bookstore[{self.get_num_books()} books]\"\n\n    def add_books(self, book_list):\n        self.books.extend(book_list)\n\n    def get_books(self):\n        return self.books\n\n    def get_inventory(self):\n        book_lines = []\n        for book_index, book in enumerate(self.get_books()):\n            cur_book_line = f\"{book_index}. {str(book)}\"\n            book_lines.append(cur_book_line)\n        return \"\\n\".join(book_lines)\n\n    def get_num_books(self):\n        return len(self.get_books())\n\n    def sort_books(self, sort_key):\n        self.books.sort(key=sort_key)\n\nclass Book:\n    def __init__(self, title, authors, num_pages):\n        self.title = title\n        self.authors = authors\n        self.num_pages = num_pages\n\n    def __str__(self):\n        return f\"Book[title={self.get_title()}, authors={self.get_authors()}, pages={self.get_num_pages()}]\"\n\n    def get_authors(self):\n        return self.authors\n\n    def get_first_author(self):\n        return self.authors[0]\n\n    def get_num_pages(self):\n        return self.num_pages\n\n    def get_title(self):\n        return self.title\n\nclass Person:\n    def __init__(self, family_name, given_name):\n        self.family_name = family_name\n        self.given_name = given_name\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return f\"Person[{self.get_family_name()}, {self.get_given_name()}]\"\n\n    def get_family_name(self):\n        return self.family_name\n\n    def get_given_name(self):\n        return self.given_name\n\n\n\n\n\nCode\nmy_bookstore = Bookstore(\"Bookland\", \"Washington, DC\")\nplath = Person(\"Plath\", \"Sylvia\")\nbell_jar = Book(\"The Bell Jar\", [plath], 244)\nmarx = Person(\"Marx\", \"Karl\")\nengels = Person(\"Engels\", \"Friedrich\")\nmanifesto = Book(\"The Communist Manifesto\", [marx, engels], 43)\nelster = Person(\"Elster\", \"Jon\")\ncement = Book(\"The Cement of Society\", [elster], 311)\nmy_bookstore.add_books([bell_jar, manifesto, cement])\nprint(my_bookstore)\nprint(my_bookstore[0])\nprint(\"Inventory:\")\nprint(my_bookstore.get_inventory())\n\n\nBookstore[3 books]\nBook[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\nInventory:\n0. Book[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\n1. Book[title=The Communist Manifesto, authors=[Person[Marx, Karl], Person[Engels, Friedrich]], pages=43]\n2. Book[title=The Cement of Society, authors=[Person[Elster, Jon]], pages=311]",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#doing-things-with-classes",
    "href": "w02/index.html#doing-things-with-classes",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Doing Things With Classes",
    "text": "Doing Things With Classes\n\nNow we can use our OOP structure, for example to sort the inventory in different ways!\n\n\n\n\nAlphabetical (By First Author)\n\n\n\nCode\nsort_alpha = lambda x: x.get_first_author().get_family_name()\nmy_bookstore.sort_books(sort_key = sort_alpha)\nprint(my_bookstore.get_inventory())\n\n\n0. Book[title=The Cement of Society, authors=[Person[Elster, Jon]], pages=311]\n1. Book[title=The Communist Manifesto, authors=[Person[Marx, Karl], Person[Engels, Friedrich]], pages=43]\n2. Book[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\n\n\n\n\nBy Page Count\n\n\n\nCode\nsort_pages = lambda x: x.get_num_pages()\nmy_bookstore.sort_books(sort_key = sort_pages)\nprint(my_bookstore.get_inventory())\n\n\n0. Book[title=The Communist Manifesto, authors=[Person[Marx, Karl], Person[Engels, Friedrich]], pages=43]\n1. Book[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\n2. Book[title=The Cement of Society, authors=[Person[Elster, Jon]], pages=311]",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#key-oop-feature-2-polymorphism",
    "href": "w02/index.html#key-oop-feature-2-polymorphism",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Key OOP Feature #2: Polymorphism",
    "text": "Key OOP Feature #2: Polymorphism\n\nEncapsulate general properties in parent class, specific properties in child classes\n\n\n\n\n(You can edit this or make your own UML diagrams in nomnoml!)",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#or-is-this-better",
    "href": "w02/index.html#or-is-this-better",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Or… Is This Better?",
    "text": "Or… Is This Better?\n\n\n\nEdit in nomnoml",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#design-choices",
    "href": "w02/index.html#design-choices",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Design Choices",
    "text": "Design Choices\n\nThe goal is to encapsulate as best as possible: which objects should have which properties, and which methods?\nExample: Fiction vs. Non-Fiction. How important is this distinction for your use case?\n\n\n\n\nOption 1: As Property of Book\n\n\n\nCode\nfrom enum import Enum\nclass BookType(Enum):\n    NONFICTION = 0\n    FICTION = 1\n\nclass Book:\n    def __init__(self, title: str, authors: list[Person], num_pages: int, type: BookType):\n        self.title = title\n        self.authors = authors\n        self.num_pages = num_pages\n        self.type = type\n\n    def __str__(self):\n        return f\"Book[title={self.title}, authors={self.authors}, pages={self.num_pages}, type={self.type}]\"\n\n\n\n\nCode\njoyce = Person(\"Joyce\", \"James\")\nulysses = Book(\"Ulysses\", [joyce], 732, BookType.FICTION)\nschelling = Person(\"Schelling\", \"Thomas\")\nmicromotives = Book(\"Micromotives and Macrobehavior\", [schelling], 252, BookType.NONFICTION)\nprint(ulysses)\nprint(micromotives)\n\n\nBook[title=Ulysses, authors=[Person[Joyce, James]], pages=732, type=BookType.FICTION]\nBook[title=Micromotives and Macrobehavior, authors=[Person[Schelling, Thomas]], pages=252, type=BookType.NONFICTION]\n\n\n\n\nOption 2: Separate Classes\n\n\n\nCode\n# class Book defined as earlier\nclass FictionBook(Book):\n    def __init__(self, title, authors, num_pages, characters):\n        super().__init__(title, authors, num_pages)\n        self.characters = characters\n\nclass NonfictionBook(Book):\n    def __init__(self, title, authors, num_pages, topic):\n        super().__init__(title, authors, num_pages)\n        self.topic = topic\n\n\n\n\nCode\njoyce = Person(\"Joyce\", \"James\")\nulysses = FictionBook(\"Ulysses\", [joyce], 732, [\"Daedalus\"])\nschelling = Person(\"Schelling\", \"Thomas\")\nmicromotives = NonfictionBook(\"Micromotives and Macrobehavior\", [schelling], 252, \"Economics\")\nprint(ulysses)\nprint(micromotives)\n\n\nBook[title=Ulysses, authors=[Person[Joyce, James]], pages=732]\nBook[title=Micromotives and Macrobehavior, authors=[Person[Schelling, Thomas]], pages=252]",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#references",
    "href": "w02/index.html#references",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "References",
    "text": "References\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2001. Introduction To Algorithms. MIT Press.\n\n\nSavage, John E. 1998. Models of Computation: Exploring the Power of Computing. Addison-Wesley.",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#appendix-the-full-master-theorem",
    "href": "w02/index.html#appendix-the-full-master-theorem",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Appendix: The Full Master Theorem",
    "text": "Appendix: The Full Master Theorem\nMaster Theorem: Let \\(a &gt; 0\\) and \\(b &gt; 1\\) be constants, and let \\(f(n)\\) be a driving function defined and nonnegative on all sufficiently large reals. Define \\(T(n)\\) on \\(n \\in \\mathbb{N}\\) by\n\\[\nT(n) = aT(n/b) + f(n)\n\\]\nwhere \\(aT(n/b) = a'T(\\lfloor n/b \\rfloor) + a''T(\\lceil n/b \\rceil)\\) for some \\(a' \\geq 0\\) and \\(a'' \\geq 0\\) satisfying \\(a = a' + a''\\). Then the asymptotic behavior of \\(T(n)\\) can be characterized as follows:\n\nIf there exists \\(\\epsilon &gt; 0\\) such that \\(f(n) = O(n^{\\log_b(a) - \\epsilon})\\), then \\(T(n) = \\Theta(n^{\\log_b(a)})\\)\nIf there exists \\(k \\geq 0\\) such that \\(f(n) = \\Theta(n^{\\log_b(a)}\\log_2^k(n))\\), then \\(T(n) = \\Theta(n^{\\log_b(a)}\\log_2^{k+1}(n))\\).\nIf there exists \\(\\epsilon &gt; 0\\) such that \\(f(n) = \\Omega(n^{\\log_b(a) + \\epsilon})\\), and if \\(f(n)\\) satisfies the regularity condition \\(af(n/b) \\leq cf(n)\\) for some constant \\(c &lt; 1\\) and all sufficiently large \\(n\\), then \\(T(n) = \\Theta(f(n))\\).\n\n\nProof. See Cormen et al. (2001), pg. 107-114.\n\n(← Back to Merge Sort slides)",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/index.html#footnotes",
    "href": "w02/index.html#footnotes",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee appendix slide for all 3 cases, if you’re some kind of masochist↩︎",
    "crumbs": [
      "Week 2: Jan 22"
    ]
  },
  {
    "objectID": "w02/slides.html#why-does-the-nyc-subway-have-express-lines",
    "href": "w02/slides.html#why-does-the-nyc-subway-have-express-lines",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Why Does The NYC Subway Have Express Lines?",
    "text": "Why Does The NYC Subway Have Express Lines?\n\nFrom NYC Central Park website"
  },
  {
    "objectID": "w02/slides.html#why-stop-at-two-levels",
    "href": "w02/slides.html#why-stop-at-two-levels",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Why Stop At Two Levels?",
    "text": "Why Stop At Two Levels?\n\nFrom Skip List Data Structure Explained, Sumit’s Diary blog"
  },
  {
    "objectID": "w02/slides.html#how-tf-does-google-maps-work",
    "href": "w02/slides.html#how-tf-does-google-maps-work",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "How TF Does Google Maps Work?",
    "text": "How TF Does Google Maps Work?\n\nA (mostly) full-on answer: soon to come! Data structures for spatial data\nA step in that direction: Quadtrees! (Fractal DC)\n\n\nJim Kang’s Quadtree Visualizations"
  },
  {
    "objectID": "w02/slides.html#the-secretly-exciting-world-of-matrix-multiplication",
    "href": "w02/slides.html#the-secretly-exciting-world-of-matrix-multiplication",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "The Secretly Exciting World of Matrix Multiplication",
    "text": "The Secretly Exciting World of Matrix Multiplication\n\nFun Fact 1: Most of modern Machine Learning is, at the processor level, just a bunch of matrix operations\nFun Fact 2: The way we’ve all learned how to multiply matrices requires \\(O(N^3)\\) operations, for two \\(N \\times N\\) matrices \\(A\\) and \\(B\\)\nFun Fact 3: \\(\\underbrace{x^2 - y^2}_{\\mathclap{\\times\\text{ twice, }\\pm\\text{ once}}} = \\underbrace{(x+y)(x-y)}_{\\times\\text{once, }\\pm\\text{ twice}}\\)\nFun Fact 4: These are not very fun facts at all"
  },
  {
    "objectID": "w02/slides.html#why-is-jeff-rambling-about-matrix-math-from-300-years-ago",
    "href": "w02/slides.html#why-is-jeff-rambling-about-matrix-math-from-300-years-ago",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Why Is Jeff Rambling About Matrix Math From 300 Years Ago?",
    "text": "Why Is Jeff Rambling About Matrix Math From 300 Years Ago?\n\nThe way we all learned it in school (for \\(N = 2\\)):\n\n\\[\nAB = \\begin{bmatrix}\na_{11} & a_{12} \\\\\na_{21} & a_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\nb_{11} & b_{12} \\\\\nb_{21} & b_{22}\n\\end{bmatrix} =\n\\begin{bmatrix}\na_{11}b_{11} + a_{12}b_{21} & a_{11}b_{12} + a_{12}b_{22} \\\\\na_{21}b_{11} + a_{22}b_{21} & a_{21}b_{12} + a_{22}b_{22}\n\\end{bmatrix}\n\\]\n\n12 operations: 8 multiplications, 4 additions \\(\\implies O(N^3) = O(2^3) = O(8)\\)\nAre we trapped? Like… what is there to do besides performing these \\(N^3\\) operations, if we want to multiply two \\(N \\times N\\) matrices? Why are we about to move onto yet another slide about this?"
  },
  {
    "objectID": "w02/slides.html#block-partitioning-matrices",
    "href": "w02/slides.html#block-partitioning-matrices",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Block-Partitioning Matrices",
    "text": "Block-Partitioning Matrices\n\nNow let’s consider big matrices, whose dimensions are a power of 2 (for ease of illustration): \\(A\\) and \\(B\\) are now \\(N \\times N = 2^n \\times 2^n\\) matrices\nWe can “decompose” the matrix product \\(AB\\) as:\n\n\\[\nAB = \\begin{bmatrix}\nA_{11} & A_{12} \\\\\nA_{21} & A_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\nB_{11} & B_{12} \\\\\nB_{21} & B_{22}\n\\end{bmatrix} =\n\\begin{bmatrix}\nA_{11}B_{11} + A_{12}B_{21} & A_{11}B_{12} + A_{12}B_{22} \\\\\nA_{21}B_{11} + A_{22}B_{21} & A_{21}B_{12} + A_{22}B_{22}\n\\end{bmatrix}\n\\]\n\nWhich gives us a recurrence relation representing the total number of computations required for this big-matrix multiplication: \\(T(N) = \\underbrace{8T(N/2)}_{\\text{Multiplications}} + \\underbrace{\\Theta(1)}_{\\text{Additions}}\\)\nIt turns out that (using a method we’ll learn in Week 3), given this recurrence relation and our base case from the previous slide, this divide-and-conquer approach via block-partitioning doesn’t help us: we still get \\(T(n) = O(n^3)\\)…\nSo why is Jeff still torturing us with this example?"
  },
  {
    "objectID": "w02/slides.html#time-for-some-matrix-magic",
    "href": "w02/slides.html#time-for-some-matrix-magic",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Time For Some 🪄MATRIX MAGIC!🪄",
    "text": "Time For Some 🪄MATRIX MAGIC!🪄\n\n\nIf we define\n\n\\[\n\\begin{align*}\nm_1 &= (a_{11}+a_{22})(b_{11}+b_{22}) \\\\\nm_2 &= (a_{21}+a_{22})b_{11} \\\\\nm_3 &= a_{11}(b_{12}-b_{22}) \\\\\nm_4 &= a_{22}(b_{21}-b_{11}) \\\\\nm_5 &= (a_{11}+a_{12})b_{22} \\\\\nm_6 &= (a_{21}-a_{11})(b_{11}+b_{12}) \\\\\nm_7 &= (a_{12}-a_{22})(b_{21}+b_{22})\n\\end{align*}\n\\]\n\n\n\nThen we can combine these seven scalar products to obtain our matrix product:\n\n\\[\nAB = \\begin{bmatrix}\nm_1 + m_4 - m_5 + m_7 & m_3 + m_5 \\\\\nm_2 + m_4 & m_1 - m_2 + m_3 + m_6\n\\end{bmatrix}\n\\]\n\n\nTotal operations: 7 multiplications, 18 additions"
  },
  {
    "objectID": "w02/slides.html#block-partitioned-matrix-magic",
    "href": "w02/slides.html#block-partitioned-matrix-magic",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Block-Partitioned Matrix Magic",
    "text": "Block-Partitioned Matrix Magic\n\nUsing the previous slide as our base case and applying this same method to the block-paritioned big matrices, we get the same result, but where the four entries in \\(AB\\) here are now matrices rather than scalars:\n\n\\[\nAB = \\begin{bmatrix}\nM_1 + M_4 - M_5 + M_7 & M_3 + M_5 \\\\\nM_2 + M_4 & M_1 - M_2 + M_3 + M_6\n\\end{bmatrix}\n\\]\n\nWe now have a different recurrence relation: \\(T(N) = \\underbrace{7T(N/2)}_{\\text{Multiplications}} + \\underbrace{\\Theta(N^2)}_{\\text{Additions}}\\)\nAnd it turns out, somewhat miraculously, that the additional time required for the increased number of additions is significantly less than the time savings we obtain by doing 7 instead of 8 multiplications, since this method now runs in \\(T(N) = O(N^{\\log_2(7)}) \\approx O(N^{2.807}) &lt; O(N^3)\\) 🤯"
  },
  {
    "objectID": "w02/slides.html#insertion-sort",
    "href": "w02/slides.html#insertion-sort",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Insertion Sort",
    "text": "Insertion Sort\n\nThink of how you might sort a deck of cards in your hand"
  },
  {
    "objectID": "w02/slides.html#cards-rightarrow-list-elements",
    "href": "w02/slides.html#cards-rightarrow-list-elements",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Cards \\(\\rightarrow\\) List Elements",
    "text": "Cards \\(\\rightarrow\\) List Elements\n\nInput list: [5, 2, 4, 6, 1, 3]\n\n\n\nNotice how, at each point:\n\nThere is a card we’re currently “looking at”, called the key, and\nThere is an invariant: everything in the list before the key is already sorted"
  },
  {
    "objectID": "w02/slides.html#complexity-analysis",
    "href": "w02/slides.html#complexity-analysis",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Complexity Analysis",
    "text": "Complexity Analysis\n\nLet \\(t_i\\) be the number of times the while loop runs, \\(\\widetilde{n} = n - 1\\):\n\n\n\n\n\nCode\nCost\nTimes Run\n\n\n\n\n1\nfor i = 1 to n-1:\n\\(c_1\\)\n\\(\\widetilde{n}\\)\n\n\n2\n  key = A[i]\n\\(c_2\\)\n\\(\\widetilde{n}\\)\n\n\n3\n  # Insert A[i] into sorted subarray A[0:i-1]\n\\(0\\)\n\\(\\widetilde{n}\\)\n\n\n4\n  j = i - 1\n\\(c_4\\)\n\\(\\widetilde{n}\\)\n\n\n5\n  while j &gt;= 0 and A[j] &gt; key:\n\\(c_5\\)\n\\(\\sum_{i=2}^n t_i\\)\n\n\n6\n    A[j + 1] = A[j]\n\\(c_6\\)\n\\(\\sum_{i=2}^n(t_i - 1)\\)\n\n\n7\n    j = j - 1\n\\(c_7\\)\n\\(\\sum_{i=2}^n(t_i - 1)\\)\n\n\n8\n  A[j + 1] = key\n\\(c_8\\)\n\\(\\widetilde{n}\\)\n\n\n\n\\[\nT(n) = c_1\\widetilde{n} + c_2\\widetilde{n} + c_4\\widetilde{n} + c_5\\sum_{i=2}^nt_i + c_6\\sum_{i=2}^n(t_i - 1) + c_7\\sum_{i=2}^n(t_i-1) + c_8\\widetilde{n}\n\\]"
  },
  {
    "objectID": "w02/slides.html#simplifying",
    "href": "w02/slides.html#simplifying",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Simplifying",
    "text": "Simplifying\n\nThe original, scary-looking equation:\n\n\\[\nT(n) = c_1n + c_2\\widetilde{n} + c_4\\widetilde{n} + c_5{\\color{orange}\\boxed{\\color{black}\\sum_{i=2}^nt_i}} + c_6{\\color{lightblue}\\boxed{\\color{black}\\sum_{i=2}^n(t_i - 1)}} + c_7{\\color{lightblue}\\boxed{\\color{black}\\sum_{i=2}^n(t_i-1)}} + c_8\\widetilde{n}\n\\]\n\nBut \\(\\sum_{i=1}^ni = \\frac{n(n+1)}{2}\\), so:\n\n\\[\n\\begin{align*}\n{\\color{orange}\\boxed{\\color{black}\\sum_{i=2}^ni}} &= \\sum_{i=1}^ni - \\sum_{i=1}^1i = \\frac{n(n+1)}{2} - 1 \\\\\n{\\color{lightblue}\\boxed{\\color{black}\\sum_{i=2}^n(i-1)}} &= \\sum_{i=1}^{n-1}i = \\frac{(n-1)(n-1+1)}{2} = \\frac{n(n-1)}{2}\n\\end{align*}\n\\]\n\nAnd the scary-looking equation simplifies to\n\n\\[\n\\begin{align*}\nT(n) = &{\\color{gray}\\left(\\frac{c_5}{2} + \\frac{c_6}{2} + \\frac{c_7}{2}\\right)}{\\color{green}n^2} + {\\color{gray}\\left(c_1 + c_2 + c_4 + \\frac{c_5}{2} - \\frac{c_6}{2} - \\frac{c_7}{2} + c_8\\right)}{\\color{green}n^1} \\\\\n\\phantom{T(n) = }& - {\\color{gray}(c_2 + c_4 + c_5 + c_8)}{\\color{green}n^0}\n\\end{align*}\n\\]"
  },
  {
    "objectID": "w02/slides.html#remember-asymptotic-analysis",
    "href": "w02/slides.html#remember-asymptotic-analysis",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Remember: Asymptotic Analysis!",
    "text": "Remember: Asymptotic Analysis!\n\nIt still looks pretty messy, but remember: we care about efficiency as a function of \\(n\\)!\n\n\\[\n\\begin{align*}\nT(n) = &\\underbrace{{\\color{gray}\\left(\\frac{c_5}{2} + \\frac{c_6}{2} + \\frac{c_7}{2}\\right)}}_{\\text{Constant}}\\underbrace{\\phantom{(}{\\color{green}n^2}\\phantom{)}}_{\\text{Quadratic}} \\\\\n\\phantom{T(n) = }&+ \\underbrace{{\\color{gray}\\left(c_1 + c_2 + c_4 + \\frac{c_5}{2} - \\frac{c_6}{2} - \\frac{c_7}{2} + c_8\\right)}}_{\\text{Constant}}\\underbrace{\\phantom{(}{\\color{green}n^1}\\phantom{)}}_{\\text{Linear}} \\\\\n\\phantom{T(n) = }& - \\underbrace{{\\color{gray}(c_2 + c_4 + c_5 + c_8)}}_{\\text{Constant}}\\underbrace{{\\color{green}n^0}}_{\\text{Constant}}\n\\end{align*}\n\\]\n\nSo, there’s a sense in which \\(T(n) \\approx n^2\\), for “sufficiently large” values of \\(n\\)…\nLet’s work our way towards formalizing the \\(\\approx\\)!"
  },
  {
    "objectID": "w02/slides.html#the-figure-you-should-make-in-your-brain-every-time",
    "href": "w02/slides.html#the-figure-you-should-make-in-your-brain-every-time",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "The Figure You Should Make In Your Brain Every Time",
    "text": "The Figure You Should Make In Your Brain Every Time\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nn_vals = [np.power(10, k) for k in np.arange(1, 2.75, 0.25)]\nruntime_df = pd.DataFrame({'$n$': n_vals})\nruntime_df['$n^2 + 50n$'] = runtime_df['$n$'].apply(lambda x: np.power(x, 2) + 50*x)\nruntime_df['$n^2 + 10000$'] = runtime_df['$n$'].apply(lambda x: np.power(x, 2) + 10000)\nruntime_df['$O(n)$'] = runtime_df['$n$'].copy()\nruntime_df['$O(nlogn)$'] = runtime_df['$n$'].apply(lambda x: x * np.log(x))\nruntime_df['$O(n^2)$'] = runtime_df['$n$'].apply(lambda x: np.power(x, 2))\nruntime_df['$O(n^2logn)$'] = runtime_df['$n$'].apply(lambda x: np.power(x,2) * np.log(x))\nruntime_df['$O(n^3)$'] = runtime_df['$n$'].apply(lambda x: np.power(x, 3))\nruntime_df['$O(n^3logn)$'] = runtime_df['$n$'].apply(lambda x: np.power(x, 3) * np.log(x))\n# Get the max values, for labeling the ends of lines\nmax_vals = runtime_df.max().to_dict()\nplot_df = runtime_df.melt(id_vars=['$n$'])\n#print(plot_df)\nstyle_map = {col: '' if (col == '$n^2 + 50n$') or (col == '$n^2 + 10000$') else (2,1) for col in runtime_df.columns}\nfig, ax = plt.subplots(figsize=(11,5))\nsns.lineplot(plot_df, x='$n$', y='value', hue='variable', style='variable', dashes=style_map)\n#plt.xscale('log')\nplt.yscale('log')\n# extract the existing handles and labels\nh, l = ax.get_legend_handles_labels()\n# slice the appropriate section of l and h to include in the legend\nax.legend(h[0:2], l[0:2])\nfor label, val in max_vals.items():\n  if (label == '$n$') or (label == '$n^2 + 50n$') or (label == '$n^2 + 10000$'):\n    continue\n  if 'logn' in label:\n    label = label.replace('logn', r'\\log(n)')\n  ax.text(x = max_vals['$n$'] + 2, y = val, s=label, va='center')\n# Hide the right and top spines\nax.spines[['right', 'top']].set_visible(False)\nplt.show()\n\n\n\n\n\n\n\n\n\n\nTakeaway: As \\(n \\rightarrow \\infty\\), highest-degree terms dominate!"
  },
  {
    "objectID": "w02/slides.html#constants-on-highest-degree-terms-also-go-away",
    "href": "w02/slides.html#constants-on-highest-degree-terms-also-go-away",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Constants On Highest-Degree Terms Also Go Away",
    "text": "Constants On Highest-Degree Terms Also Go Away\n\n(Though this is harder to see, without a log-log plot:)\n\n\n\nCode\nn_vals = [np.power(10, k) for k in np.arange(1, 6, 0.5)]\nrt_const_df = pd.DataFrame({'$n$': n_vals})\nrt_const_df['$20n^2$'] = rt_const_df['$n$'].apply(lambda x: 20*np.power(x,2))\nrt_const_df['$n^2$'] = rt_const_df['$n$'].apply(lambda x: np.power(x,2))\nrt_const_df['$n^2logn$'] = rt_const_df['$n$'].apply(lambda x: np.power(x,2) * np.power(np.log(x),2))\nrt_const_df['$n^3$'] = rt_const_df['$n$'].apply(lambda x: np.power(x,3))\n# Get the max values, for labeling the ends of lines\nmax_vals = rt_const_df.max().to_dict()\nplot_df_const = rt_const_df.melt(id_vars=['$n$'])\nstyle_map = {col: '' if (col == '$20n^2$') else (2,1) for col in rt_const_df.columns}\nfig_const, ax_const = plt.subplots(figsize=(11,5))\nsns.lineplot(plot_df_const, x='$n$', y='value', hue='variable', style='variable', dashes=style_map)\nplt.xscale('log')\nplt.yscale('log')\n# extract the existing handles and labels\nh_const, l_const = ax_const.get_legend_handles_labels()\n# slice the appropriate section of l and h to include in the legend\nax_const.legend(h_const[0:1], l_const[0:1])\nfor label, val in max_vals.items():\n  if (label == '$n$') or (label == '$20n^2$'):\n    continue\n  if 'logn' in label:\n    label = label.replace('logn', r'\\log(n)')\n  ax_const.text(x = max_vals['$n$'] + 10**4, y = val, s=label, va='center')\n# Hide the right and top spines\nax_const.spines[['right', 'top']].set_visible(False)\nplt.show()"
  },
  {
    "objectID": "w02/slides.html#formalizing-big-o-notation",
    "href": "w02/slides.html#formalizing-big-o-notation",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Formalizing Big-O Notation",
    "text": "Formalizing Big-O Notation\n\nLet \\(f, g: \\mathbb{N} \\rightarrow \\mathbb{N}\\). Then we write \\(f(n) = O(g(n))\\) when there exists a threshold \\(n_0 &gt; 0\\) and a constant \\(K &gt; 0\\) such that \\[\n\\forall n \\geq n_0 \\left[ f(n) \\leq K\\cdot g(n) \\right]\n\\]\nIn words: beyond a certain point \\(n_0\\), \\(f(n)\\) is bounded above by \\(K\\cdot g(n)\\).\nDefinition from Savage (1998, pg. 13)"
  },
  {
    "objectID": "w02/slides.html#intuition-rightarrow-proof",
    "href": "w02/slides.html#intuition-rightarrow-proof",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Intuition \\(\\rightarrow\\) Proof",
    "text": "Intuition \\(\\rightarrow\\) Proof\n\nUsing this definition, we can now prove \\(f(n) = n^2 + 50n = O(n^2)\\)!\nHere \\(f(n) = n^2 + 50n\\), \\(g(n) = n^2\\)\nTheorem: \\(\\exists \\; n_0 \\; \\text{ s.t. } \\forall n \\geq n_0 \\left[ n^2 + 50n \\leq Kn^2 \\right]\\)\nProof: Let \\(K = 50\\). Then \\[\n\\begin{align*}\n&n^2 + 50n \\leq 50n^2 \\iff n + 50 \\leq 50n \\\\\n&\\iff 49n \\geq 50 \\iff n \\geq \\frac{50}{49}.\n\\end{align*}\n\\]\nSo if we choose \\(n_0 = 2\\), the chain of statements holds. \\(\\blacksquare\\)"
  },
  {
    "objectID": "w02/slides.html#bounding-insertion-sort-runtime",
    "href": "w02/slides.html#bounding-insertion-sort-runtime",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Bounding Insertion Sort Runtime",
    "text": "Bounding Insertion Sort Runtime\n\nRuns in \\(T(n) = O(n^2)\\) (use constants from prev slide)\nCan similarly define lower bound \\(T(n) = \\Omega(f(n))\\)\n\n\\(O\\) = “Big-Oh”, \\(\\Omega\\) = “Big-Omega”\n\nNeed to be careful with \\(O(f(n))\\) vs. \\(\\Omega(f(n))\\) however: difference between “for all inputs” vs. “for some inputs”:\n\n\n\n\n\nBounding Worst-Case Runtime\n\n\nBy saying that the worst-case running time of an algorithm is \\(\\Omega(n^2)\\), we mean that for every input size \\(n\\) above a certain threshold, there is at least one input of size \\(n\\) for which the algorithm takes at least \\(cn^2\\) time, for some positive constant \\(n\\). It does not necessarily mean that the algorithm takes at least \\(cn^2\\) time for all inputs."
  },
  {
    "objectID": "w02/slides.html#intuition-for-lower-bound",
    "href": "w02/slides.html#intuition-for-lower-bound",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Intuition for Lower Bound",
    "text": "Intuition for Lower Bound\n\nSpoiler: Insertion sort also runs in \\(T(n) = \\Omega(n^2)\\) time. How could we prove this?\nGiven any value \\(n &gt; n_0\\), we need to construct an input for which Insertion-Sort requires \\(cn^2\\) steps: consider a list where \\(n/3\\) greatest values are in first \\(n/3\\) slots:\n\n\nAll \\(n/3\\) values in \\(\\textrm{L}\\) pass, one-by-one, through the \\(n/3\\) slots in \\(\\textrm{M}\\) (since they must end up in \\(\\textrm{R}\\)) \\(\\implies (n/3)(n/3) = n^2/9 = \\Omega(n^2)\\) steps!\nFinal definition (a theorem you could prove if you want!): \\(\\Theta\\) = “Big-Theta”\n\nIf \\(T(n) = \\overline{O}(g(n))\\) and \\(T(n) = \\Omega(g(n))\\), then \\(T(n) = \\Theta(n)\\)\n\n\\(\\implies\\) most “informative” way to characterize insertion sort is \\(\\boxed{T(n) = \\Theta(n^2)}\\)"
  },
  {
    "objectID": "w02/slides.html#doing-better-than-insertion-sort",
    "href": "w02/slides.html#doing-better-than-insertion-sort",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Doing Better Than Insertion Sort",
    "text": "Doing Better Than Insertion Sort\n\nIntuition Break 🥳: Finding a word in a dictionary! dsan.io/dict-lookup"
  },
  {
    "objectID": "w02/slides.html#how-can-merge-sort-work-that-much-better",
    "href": "w02/slides.html#how-can-merge-sort-work-that-much-better",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "How Can Merge Sort Work That Much Better!?",
    "text": "How Can Merge Sort Work That Much Better!?\n\nWith the linear approach, each time we check a word and it’s not our word we eliminate… one measly word 😞\nBut with the divide-and-conquer approach… we eliminate 🔥HALF OF THE REMAINING WORDS🔥"
  },
  {
    "objectID": "w02/slides.html#merging-two-sorted-lists-in-on-time",
    "href": "w02/slides.html#merging-two-sorted-lists-in-on-time",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Merging Two Sorted Lists in \\(O(n)\\) Time",
    "text": "Merging Two Sorted Lists in \\(O(n)\\) Time\n\nFrom Cormen et al. (2001), pg. 37"
  },
  {
    "objectID": "w02/slides.html#merge-sort-merging-as-subroutine",
    "href": "w02/slides.html#merge-sort-merging-as-subroutine",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Merge Sort (Merging as Subroutine)",
    "text": "Merge Sort (Merging as Subroutine)\n\nFrom Cormen et al. (2001), pg. 40"
  },
  {
    "objectID": "w02/slides.html#complexity-analysis-1",
    "href": "w02/slides.html#complexity-analysis-1",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Complexity Analysis",
    "text": "Complexity Analysis\n\nHard way: re-do the line-by-line analysis we did for Insertion-Sort 😣 Easy way: stand on shoulders of giants!\nUsing a famous+fun theorem (the Master Theorem): Given a recurrence \\(T(n) = aT(n/b) + f(n)\\), compute its:\n\nWatershed function \\(W(n) = n^{\\log_b(a)}\\) and\nDriving function \\(D(n) = f(n)\\)\n\nThe Master Theorem gives closed-form asymptotic solution for \\(T(n)\\), split into three cases:\n(1) \\(W(n)\\) grows faster than \\(D(n)\\), (2) grows at same rate as \\(D(n)\\), or (3) grows slower than \\(D(n)\\)"
  },
  {
    "objectID": "w02/slides.html#bounding-the-runtime-of-merge-sort",
    "href": "w02/slides.html#bounding-the-runtime-of-merge-sort",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Bounding the Runtime of Merge Sort",
    "text": "Bounding the Runtime of Merge Sort\n\nHow about Merge-Sort? \\(T(n) = 2T(n/2) + \\Theta(n)\\)\n\n\\(a = b = 2\\), \\(W(n) = n^{\\log_2(2)} = n\\), \\(D(n) = \\Theta(n)\\)\n\n\\(W(n)\\) and \\(D(n)\\) grow at same rate \\(\\implies\\) Case 21:\n\n\n\n\n\nApplying the Master Theorem When \\(W(n) = \\Theta(D(n))\\) (Case 2)\n\n\n\nIs there a \\(k \\geq 0\\) satisfying \\(D(n) = \\Theta(n^{\\log_b(a)}\\log_2^k(n))\\)?\nIf so, your solution is \\(T(n) = \\Theta(n^{\\log_b(a)}\\log_2^{k+1}(n))\\)\n\n\n\n\n\n\nMerge-Sort: \\(k = 0\\) works! \\(\\Theta(n^{\\log_2(2)}\\log_2^0(n)) = \\Theta(n)\\)\nThus \\(T(n) = \\Theta(n^{\\log_b(a)}\\log_2^{k+1}(n)) = \\boxed{\\Theta(n\\log_2n)}\\) 😎\n\nSee appendix slide for all 3 cases, if you’re some kind of masochist"
  },
  {
    "objectID": "w02/slides.html#breaking-a-problem-into-interacting-parts",
    "href": "w02/slides.html#breaking-a-problem-into-interacting-parts",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Breaking a Problem into (Interacting) Parts",
    "text": "Breaking a Problem into (Interacting) Parts\n\nPython so far: “Data science mode”\n\nStart at top of file with raw data\nWrite lines of code until problem solved\n\nPython in this class: “Software engineering mode”\n\nBreak system down into parts\nWrite each part separately\nLink parts together to create the whole\n\n(One implication: .py files may be easier than .ipynb for development!)"
  },
  {
    "objectID": "w02/slides.html#how-does-a-calculator-work",
    "href": "w02/slides.html#how-does-a-calculator-work",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "How Does A Calculator Work?",
    "text": "How Does A Calculator Work?\n\n(Calculator image from Wikimedia Commons)"
  },
  {
    "objectID": "w02/slides.html#key-oop-feature-1-encapsulation",
    "href": "w02/slides.html#key-oop-feature-1-encapsulation",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Key OOP Feature #1: Encapsulation",
    "text": "Key OOP Feature #1: Encapsulation\n\nImagine you’re on a team trying to make a calculator\nOne person can write the Screen class, another person can write the Button class, and so on\nNatural division of labor! (May seem silly for a calculator, but imagine as your app scales up)"
  },
  {
    "objectID": "w02/slides.html#use-case-bookstore-inventory-management",
    "href": "w02/slides.html#use-case-bookstore-inventory-management",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Use Case: Bookstore Inventory Management",
    "text": "Use Case: Bookstore Inventory Management\n\nImage source"
  },
  {
    "objectID": "w02/slides.html#in-pictures",
    "href": "w02/slides.html#in-pictures",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "In Pictures",
    "text": "In Pictures\n\n\n\n\n\n\nG\n\nBookstore Relational Diagram\n\n\nBookstore\n\nBookstore\n\nName\n\nLocation\n\nBooklist\n\nGet_Inventory()\n\nSort_Inventory()\n\n\n\nPlace\n\nPlace\n\nCity\n\nState\n\nCountry\n\nPrint_Map()\n\n\n\nBookstore:loc-&gt;Place:placehead\n\n\nHas One\n\n\n\nBook\n\nBook\n\nTitle\n\nAuthors\n\nNum Pages\n\nPreview()\n\n\n\nBookstore:bl-&gt;Book:bookhead\n\n\nHas Multiple\n\n\n\nPerson\n\nPerson\n\nFamily Name\n\nGiven Name\n\n\n\nBook:auths-&gt;Person:personhead\n\n\nHas Multiple"
  },
  {
    "objectID": "w02/slides.html#creating-classes",
    "href": "w02/slides.html#creating-classes",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Creating Classes",
    "text": "Creating Classes\n\nUse case: Creating an inventory system for a Bookstore\n\n\n\n\n\nCode\nclass Bookstore:\n    def __init__(self, name, location):\n        self.name = name\n        self.location = location\n        self.books = []\n\n    def __getitem__(self, index):\n        return self.books[index]\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return f\"Bookstore[{self.get_num_books()} books]\"\n\n    def add_books(self, book_list):\n        self.books.extend(book_list)\n\n    def get_books(self):\n        return self.books\n\n    def get_inventory(self):\n        book_lines = []\n        for book_index, book in enumerate(self.get_books()):\n            cur_book_line = f\"{book_index}. {str(book)}\"\n            book_lines.append(cur_book_line)\n        return \"\\n\".join(book_lines)\n\n    def get_num_books(self):\n        return len(self.get_books())\n\n    def sort_books(self, sort_key):\n        self.books.sort(key=sort_key)\n\nclass Book:\n    def __init__(self, title, authors, num_pages):\n        self.title = title\n        self.authors = authors\n        self.num_pages = num_pages\n\n    def __str__(self):\n        return f\"Book[title={self.get_title()}, authors={self.get_authors()}, pages={self.get_num_pages()}]\"\n\n    def get_authors(self):\n        return self.authors\n\n    def get_first_author(self):\n        return self.authors[0]\n\n    def get_num_pages(self):\n        return self.num_pages\n\n    def get_title(self):\n        return self.title\n\nclass Person:\n    def __init__(self, family_name, given_name):\n        self.family_name = family_name\n        self.given_name = given_name\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return f\"Person[{self.get_family_name()}, {self.get_given_name()}]\"\n\n    def get_family_name(self):\n        return self.family_name\n\n    def get_given_name(self):\n        return self.given_name\n\n\n\n\n\nCode\nmy_bookstore = Bookstore(\"Bookland\", \"Washington, DC\")\nplath = Person(\"Plath\", \"Sylvia\")\nbell_jar = Book(\"The Bell Jar\", [plath], 244)\nmarx = Person(\"Marx\", \"Karl\")\nengels = Person(\"Engels\", \"Friedrich\")\nmanifesto = Book(\"The Communist Manifesto\", [marx, engels], 43)\nelster = Person(\"Elster\", \"Jon\")\ncement = Book(\"The Cement of Society\", [elster], 311)\nmy_bookstore.add_books([bell_jar, manifesto, cement])\nprint(my_bookstore)\nprint(my_bookstore[0])\nprint(\"Inventory:\")\nprint(my_bookstore.get_inventory())\n\n\nBookstore[3 books]\nBook[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\nInventory:\n0. Book[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\n1. Book[title=The Communist Manifesto, authors=[Person[Marx, Karl], Person[Engels, Friedrich]], pages=43]\n2. Book[title=The Cement of Society, authors=[Person[Elster, Jon]], pages=311]"
  },
  {
    "objectID": "w02/slides.html#doing-things-with-classes",
    "href": "w02/slides.html#doing-things-with-classes",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Doing Things With Classes",
    "text": "Doing Things With Classes\n\nNow we can use our OOP structure, for example to sort the inventory in different ways!\n\n\n\n\nAlphabetical (By First Author)\n\n\n\nCode\nsort_alpha = lambda x: x.get_first_author().get_family_name()\nmy_bookstore.sort_books(sort_key = sort_alpha)\nprint(my_bookstore.get_inventory())\n\n\n0. Book[title=The Cement of Society, authors=[Person[Elster, Jon]], pages=311]\n1. Book[title=The Communist Manifesto, authors=[Person[Marx, Karl], Person[Engels, Friedrich]], pages=43]\n2. Book[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\n\n\n\n\nBy Page Count\n\n\n\nCode\nsort_pages = lambda x: x.get_num_pages()\nmy_bookstore.sort_books(sort_key = sort_pages)\nprint(my_bookstore.get_inventory())\n\n\n0. Book[title=The Communist Manifesto, authors=[Person[Marx, Karl], Person[Engels, Friedrich]], pages=43]\n1. Book[title=The Bell Jar, authors=[Person[Plath, Sylvia]], pages=244]\n2. Book[title=The Cement of Society, authors=[Person[Elster, Jon]], pages=311]"
  },
  {
    "objectID": "w02/slides.html#key-oop-feature-2-polymorphism",
    "href": "w02/slides.html#key-oop-feature-2-polymorphism",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Key OOP Feature #2: Polymorphism",
    "text": "Key OOP Feature #2: Polymorphism\n\nEncapsulate general properties in parent class, specific properties in child classes\n\n\n(You can edit this or make your own UML diagrams in nomnoml!)"
  },
  {
    "objectID": "w02/slides.html#or-is-this-better",
    "href": "w02/slides.html#or-is-this-better",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Or… Is This Better?",
    "text": "Or… Is This Better?\n\nEdit in nomnoml"
  },
  {
    "objectID": "w02/slides.html#design-choices",
    "href": "w02/slides.html#design-choices",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Design Choices",
    "text": "Design Choices\n\nThe goal is to encapsulate as best as possible: which objects should have which properties, and which methods?\nExample: Fiction vs. Non-Fiction. How important is this distinction for your use case?\n\n\n\n\nOption 1: As Property of Book\n\n\n\nCode\nfrom enum import Enum\nclass BookType(Enum):\n    NONFICTION = 0\n    FICTION = 1\n\nclass Book:\n    def __init__(self, title: str, authors: list[Person], num_pages: int, type: BookType):\n        self.title = title\n        self.authors = authors\n        self.num_pages = num_pages\n        self.type = type\n\n    def __str__(self):\n        return f\"Book[title={self.title}, authors={self.authors}, pages={self.num_pages}, type={self.type}]\"\n\n\n\n\nCode\njoyce = Person(\"Joyce\", \"James\")\nulysses = Book(\"Ulysses\", [joyce], 732, BookType.FICTION)\nschelling = Person(\"Schelling\", \"Thomas\")\nmicromotives = Book(\"Micromotives and Macrobehavior\", [schelling], 252, BookType.NONFICTION)\nprint(ulysses)\nprint(micromotives)\n\n\nBook[title=Ulysses, authors=[Person[Joyce, James]], pages=732, type=BookType.FICTION]\nBook[title=Micromotives and Macrobehavior, authors=[Person[Schelling, Thomas]], pages=252, type=BookType.NONFICTION]\n\n\n\n\nOption 2: Separate Classes\n\n\n\nCode\n# class Book defined as earlier\nclass FictionBook(Book):\n    def __init__(self, title, authors, num_pages, characters):\n        super().__init__(title, authors, num_pages)\n        self.characters = characters\n\nclass NonfictionBook(Book):\n    def __init__(self, title, authors, num_pages, topic):\n        super().__init__(title, authors, num_pages)\n        self.topic = topic\n\n\n\n\nCode\njoyce = Person(\"Joyce\", \"James\")\nulysses = FictionBook(\"Ulysses\", [joyce], 732, [\"Daedalus\"])\nschelling = Person(\"Schelling\", \"Thomas\")\nmicromotives = NonfictionBook(\"Micromotives and Macrobehavior\", [schelling], 252, \"Economics\")\nprint(ulysses)\nprint(micromotives)\n\n\nBook[title=Ulysses, authors=[Person[Joyce, James]], pages=732]\nBook[title=Micromotives and Macrobehavior, authors=[Person[Schelling, Thomas]], pages=252]"
  },
  {
    "objectID": "w02/slides.html#references",
    "href": "w02/slides.html#references",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "References",
    "text": "References\n\n\nCormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2001. Introduction To Algorithms. MIT Press.\n\n\nSavage, John E. 1998. Models of Computation: Exploring the Power of Computing. Addison-Wesley."
  },
  {
    "objectID": "w02/slides.html#appendix-the-full-master-theorem",
    "href": "w02/slides.html#appendix-the-full-master-theorem",
    "title": "Week 2: Software Design Patterns and Object-Oriented Programming",
    "section": "Appendix: The Full Master Theorem",
    "text": "Appendix: The Full Master Theorem\nMaster Theorem: Let \\(a &gt; 0\\) and \\(b &gt; 1\\) be constants, and let \\(f(n)\\) be a driving function defined and nonnegative on all sufficiently large reals. Define \\(T(n)\\) on \\(n \\in \\mathbb{N}\\) by\n\\[\nT(n) = aT(n/b) + f(n)\n\\]\nwhere \\(aT(n/b) = a'T(\\lfloor n/b \\rfloor) + a''T(\\lceil n/b \\rceil)\\) for some \\(a' \\geq 0\\) and \\(a'' \\geq 0\\) satisfying \\(a = a' + a''\\). Then the asymptotic behavior of \\(T(n)\\) can be characterized as follows:\n\nIf there exists \\(\\epsilon &gt; 0\\) such that \\(f(n) = O(n^{\\log_b(a) - \\epsilon})\\), then \\(T(n) = \\Theta(n^{\\log_b(a)})\\)\nIf there exists \\(k \\geq 0\\) such that \\(f(n) = \\Theta(n^{\\log_b(a)}\\log_2^k(n))\\), then \\(T(n) = \\Theta(n^{\\log_b(a)}\\log_2^{k+1}(n))\\).\nIf there exists \\(\\epsilon &gt; 0\\) such that \\(f(n) = \\Omega(n^{\\log_b(a) + \\epsilon})\\), and if \\(f(n)\\) satisfies the regularity condition \\(af(n/b) \\leq cf(n)\\) for some constant \\(c &lt; 1\\) and all sufficiently large \\(n\\), then \\(T(n) = \\Theta(f(n))\\).\n\n\nProof. See Cormen et al. (2001), pg. 107-114.\n\n(← Back to Merge Sort slides)\n\n\n\nDSAN 5500 Week 2: Software Design Patterns and OOP"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DSAN 5500: Data Structures, Objects, and Algorithms in Python",
    "section": "",
    "text": "Welcome to the homepage for DSAN 5500: Data Structures, Objects, and Algorithms in Python, Spring 2024, at Georgetown University! The course takes place on Mondays from 12:30 to 3:00pm in Car Barn Room 204. More details are provided on the syllabus.\n\n\n\n\n\n\n\n\n\nTitle\n\n\nDate\n\n\n\n\n\n\nWeek 1: Course Intro and Motivation\n\n\nJanuary 10\n\n\n\n\nWeek 2: Software Design Patterns and Object-Oriented Programming\n\n\nJanuary 22\n\n\n\n\nWeek 3: Data Structures and Computational Complexity\n\n\nJanuary 29\n\n\n\n\nWeek 4: Heaps, Stacks, Trees, Graphs\n\n\nJanuary 10\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "<i class='bi bi-house pe-1'></i> Home"
    ]
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Syllabus",
    "section": "",
    "text": "Welcome to DSAN 5500: Data Structures, Objects, and Algorithms in Python! The course meets on Mondays from 12:30pm to 3:00pm in Car Barn Room 204.",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#course-staff",
    "href": "syllabus.html#course-staff",
    "title": "Syllabus",
    "section": "Course Staff",
    "text": "Course Staff\n\nProf. Jeff Jacobs, jj1088@georgetown.edu\n\nOffice hours (Click to reserve): Monday, Tuesday 3:30-6pm, held in Car Barn Room 207-04A\n\nTA Yihan Bian, yb214@georgetown.edu\n\nOffice hours: By appointment\n\nTA Binhui Chen, bc928@georgetown.edu\n\nOffice hours (Click to reserve): Wednesday, 3:30-4:30pm, held on Zoom\n\nTA Brian Kwon, sk2338@georgetown.edu\n\nOffice hours: By appointment",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#course-overview",
    "href": "syllabus.html#course-overview",
    "title": "Syllabus",
    "section": "Course Overview",
    "text": "Course Overview\nMy goal, in creating the course, is to take the general, language-agnostic data science concepts you’ve learned in (e.g.) DSAN 5000 and work through how to implement these concepts efficiently in Python, where we can define “efficient” in different ways based on different goals that we may have in different settings while working as Data Scientists.\nThe graded components for the course consist of five homework assignments, an in-class midterm, and a final project. Grades will be allocated as follows:\n\n\n\nCategory\nPercent of Final Grade\n\n\n\n\nIn-Class Midterm\n30%\n\n\nFinal Project\n30%\n\n\nHomeworks\n40%\n\n\nHW1: Python Fundamentals\n8%\n\n\nHW2: Data Structures\n8%\n\n\nHW3: Basic Algorithms\n8%\n\n\nHW4: Advanced Algorithms\n8%\n\n\nHW5: Parallel Computing\n8%\n\n\n\nThe course does not have any “official” prerequisites, but a general comfort with Python is strongly recommended. If you have never used Python before, however (or if you haven’t used it in a while and feel like your skills are rusty), you can browse the materials on the Resources page!",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#course-topics-calendar",
    "href": "syllabus.html#course-topics-calendar",
    "title": "Syllabus",
    "section": "Course Topics / Calendar",
    "text": "Course Topics / Calendar\nThe following is a rough map of what we will work through together throughout the semester; given that everyone learns at a different pace, my aim is to leave us with a good amount of flexibility in terms of how much time we spend on each topic: if I find that it takes me longer than a week to convey a certain topic in sufficient depth, for example, then I view it as a strength rather than a weakness of the course that we can then rearrange the calendar below by adding an extra week on that particular topic! Similarly, if it seems like I am spending too much time on a topic, to the point that students seem bored or impatient to move onto the next topic, we can move a topic intended for the next week to the current week!\n\n\n\nUnit\nWeek\nDate\nTopic\n\n\n\n\nUnit 1: Python Fundamentals\n1\nJan 10 (Wednesday)\nPython Fundamentals\n\n\n\n\nJan 15\nNo Class (Martin Luther King, Jr. Day)\n\n\n\n2\nJan 22\nData Structures and Computational Complexity\n\n\n\n3\nJan 29\nSoftware Design Patterns and OOP\n\n\n\n\nFeb 2 (Friday), 11:59pm EST\nHW1 (Python Fundamentals) Due\n\n\nUnit 2: Data Structures and Algorithms\n4\nFeb 5\nHeaps, Stacks, Trees, Graphs\n\n\n\n5\nFeb 12\nSearch Trees\n\n\n\n6\nFeb 20 (Tuesday)\nSorting Algorithms\n\n\n\n\nFeb 23 (Friday), 11:59pm EST\nHW2 (Data Structures, Algorithms, and Complexity) Due\n\n\nMidterm\n7\nFeb 26\nIn-Class Midterm\n\n\n\n\nMar 4\nNo Class (Spring Break)\n\n\nUnit 4: Advanced Algorithms\n8\nMar 11\nGraph Algorithms\n\n\n\n9\nMar 18\nAlgorithms for Spatial Data\n\n\n\n10\nMar 25\nBuilding Efficient Data Pipelines\n\n\n\n\nMar 27 (Wednesday), 11:59pm EST\nHW4 (Advanced Algorithms) Due\n\n\n\n\nApr 1\nNo Class (Easter Break)\n\n\nUnit 5: Parallel Computing\n11\nApr 8\nParallel Computing and MapReduce\n\n\n\n12\nApr 15\nParallel Computing Part 2\n\n\n\n\nApr 19 (Friday), 11:59pm EST\nHW5 (Parallel Computing) Due\n\n\nUnit 6: Advanced Topics and Applications\n13\nApr 22\nApplications in Bioinformatics\n\n\n\n14\nApr 29\nApplications in NLP",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#assignment-distribution-submission-and-grading",
    "href": "syllabus.html#assignment-distribution-submission-and-grading",
    "title": "Syllabus",
    "section": "Assignment Distribution, Submission, and Grading",
    "text": "Assignment Distribution, Submission, and Grading\nThe programming assignments for the course will be managed through Google Classroom. This means that, to work on and submit the assignments, you will use the following workflow:\n\nOpen the .ipynb file for the assignment from within Google Classroom\nWork on the problems within the file, saving your progress early and often! You can try things out or create drafts of your solutions however you’d like (for example, in VSCode or JupyterLab or any other IDE), but your final submission for each assignment must be submitted through the Google Classroom interface!\nSubmit the completed version of the assignment by clicking the blue “Hand in” button on the assignment page.\n\nThe interface allows you to unsubmit and continue working on an assignment, for example if you find a mistake, but be careful and make sure you resubmit once you’ve fixed the mistake, since submissions will not be accepted after the grace period for late submission has ended.",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#final-letter-grade-determination",
    "href": "syllabus.html#final-letter-grade-determination",
    "title": "Syllabus",
    "section": "Final Letter Grade Determination",
    "text": "Final Letter Grade Determination\nOnce all assignments have been graded, we will compute your final numeric grade according to the above weighting, rounded to two decimal places. The letter grade that we report to Georgetown on the basis of this numeric grade will then follow the DSAN letter grade policy as follows, where the start and end points for each range are inclusive:\n\n\n\nRange Start\nRange End\nLetter Grade\n\n\n\n\n92.50\n100.00\nA\n\n\n89.50\n92.49\nA-\n\n\n87.99\n89.49\nB+\n\n\n81.50\n87.98\nB\n\n\n79.50\n81.49\nB-\n\n\n69.50\n79.49\nC\n\n\n59.50\n69.49\nD\n\n\n0.00\n59.49\nF",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#official-course-description",
    "href": "syllabus.html#official-course-description",
    "title": "Syllabus",
    "section": "Official Course Description",
    "text": "Official Course Description\nThe Data Structures, Objects, and Algorithms in Python course will look at built-in data structures, such as dictionaries, lists, tuples, sets, strings, and frozen sets. The course will also cover objects and classes in Python, as well as building new structures and objects. The class will cover algorithms including runtime, recurrence, and development. Applications will include data science problems. Prerequisite: A working or intermediate knowledge of Python. 3 credits.",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#title-ixsexual-misconduct-statement",
    "href": "syllabus.html#title-ixsexual-misconduct-statement",
    "title": "Syllabus",
    "section": "Title IX/Sexual Misconduct Statement",
    "text": "Title IX/Sexual Misconduct Statement\nGeorgetown University and its faculty are committed to supporting survivors and those impacted by sexual misconduct, which includes sexual assault, sexual harassment, relationship violence, and stalking. Georgetown requires faculty members, unless otherwise designated as confidential, to report all disclosures of sexual misconduct to the University Title IX Coordinator or a Deputy Title IX Coordinator.\nIf you disclose an incident of sexual misconduct to a professor in or outside of the classroom (with the exception of disclosures in papers), that faculty member must report the incident to the Title IX Coordinator, or Deputy Title IX Coordinator. The coordinator will, in turn, reach out to the student to provide support, resources, and the option to meet. [Please note that the student is not required to meet with the Title IX coordinator.]. More information about reporting options and resources can be found in the Sexual Misconduct Resource Center.\nIf you would prefer to speak to someone confidentially, Georgetown has a number of fully confidential professional resources that can provide support and assistance. These resources include:\n\nHealth Education Services for Sexual Assault Response and Prevention: Confidential email sarp@georgetown.edu\nCounseling and Psychiatric Services (CAPS): 202-687-6985\n\nAfter hours you can call 833-960-3006 to reach Fonemed, a telehealth service, and ask for the on-call CAPS clinician",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#gsas-resources-and-policies-for-students",
    "href": "syllabus.html#gsas-resources-and-policies-for-students",
    "title": "Syllabus",
    "section": "GSAS Resources and Policies for Students",
    "text": "GSAS Resources and Policies for Students\nYou can find a collection of relevant resources and policies for students on the GSAS website, and the Provost’s policy on accommodating students’ religious observances on the Campus Ministry website.\nYou can also make use of the Student Academic Resource Center. In particular, within the Resource Center there is a link to Georgetown’s Disability Support page. If you believe you have a disability, you can contact the Academic Resource Center (arc@georgetown.edu) for further information. The ARC is located in the Leavey Center, Suite 335 (202-687-8354), and it is the campus office responsible for reviewing documentation provided by students with disabilities and for determining reasonable accommodations in accordance with the Americans with Disabilities Act (ADA) and University policies.",
    "crumbs": [
      "Syllabus"
    ]
  }
]