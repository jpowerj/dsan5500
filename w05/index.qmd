---
title: "Week 5: Linked Lists and Binary Search Trees"
subtitle: "*DSAN 5500: Data Structures, Objects, and Algorithms in Python*"
date: 2026-02-05
date-format: full
author: "Jeff Jacobs"
institute: "[`jj1088@georgetown.edu`](mailto:jj1088@georgetown.edu)"
lecnum: 5
jupyter: python3
categories:
  - "Class Sessions"
format:
  revealjs:
    df-print: kable
    output-file: "slides.html"
    footer: "DSAN 5500 Week 5: {{< var w05.footer >}}"
    echo: true
    code-fold: show
    scrollable: true
    slide-number: true
    html-math-method: mathjax
    theme: [default, "../dsan-globals/jjquarto.scss"]
    include-in-header:
      text: "<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css'><link rel='stylesheet' type='text/css' href='https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css'>"
    simplemenu:
      flat: true
      barhtml:
        header: "<div class='menubar'><span style='position: absolute; left: 8; padding-left: 8px;'><a href='./index.html'>&larr; Return to Notes</a></span><ul class='menu'></ul></div>"
      scale: 0.5
    revealjs-plugins:
      - simplemenu
  html:
    df-print: kable
    output-file: "index.html"
    echo: true
    code-fold: show
    html-math-method: mathjax
---

::: {.content-visible unless-format="revealjs"}

<center>
<a class="h2" href="./slides.html" target="_blank">Open slides in new window &rarr;</a>
</center>

:::

# Schedule {.smaller .small-title .crunch-title .crunch-callout .code-90 data-name="Schedule"}

Today's Planned Schedule:

| | Start | End | Topic |
|:- |:- |:- |:- |
| **Lecture** | 6:30pm | 7:00pm | [Inductive Thinking &rarr;](#induction-the-core-way-of-thinking-for-algorithm-design...) |
| | 7:00pm | 7:30pm | [`LinkedList`: Our Core *Linear* Data Structure &rarr;](#core-data-structure-linkedlist) |
| | 7:30pm | 8:00pm | [`BinarySearchTree` aka `FancyLinkedList` &rarr;](#onwards-and-upwards-fancier-algorithms) |
| **Break!** | 8:00pm | 8:10pm | |
| | 8:10pm | 9:00pm | [`HashTable`: The Final Missing Piece! &rarr;](#hash-tables) |

: {tbl-colwidths="[12,12,12,64]"}


# Induction: The Core "Way of Thinking" for Algorithm Design... {data-stack-name="Induction" .title-09}

* Jeff has messed up the "intuitive" explanation for Gauss' Sum on the board every semester since [2010](https://web.archive.org/web/20130421033633/http://www.cs.umd.edu/class/fall2010/cmsc420/)
* Most years this is a **problem**...
* But this year it's an **opportunity** to teach **induction!**

## The Intuition {.smaller .crunch-title .crunch-p}

*(What I **should have** done on the board)*

![](images/gauss_sum.svg){fig-align="center" width="85%"}

* $\Rightarrow \displaystyle\sum_{i=1}^{6} = \frac{6(6+1)}{2}$ ...but can we infer $\displaystyle \sum_{i=1}^{n} = \frac{n(n+1)}{2}$? **Not in general!**
* (When you do it's called *"Engineer's induction"*... see next slide)
* (**Double no** in this case since we assumed $n$ even!)
* But, with only slight increase in complicated-ness, can **prove it** by **induction**, which is used in... 95% of algorithm/data structures proofs! (We'll see why)

## What's Wrong With Engineers' Induction? {.smaller .crunch-title .title-12 .crunch-ul}

* What if I told you, I have a simple polynomial that we can use to **infinitely generate prime numbers!** $\boxed{f(n) = n^2 + n + 41}$... Let's try it!

:::: {layout="[25,20,55]" layout-valign="top" layout-align="center"}
::: {.column width="25%"}

| $n$ | $f(n)$ | Prime? |
| -:| -:|:-:|
| 0 | 41 | ‚úÖ |
| 1 | 43 | ‚úÖ |
| 2 | 47 | ‚úÖ |
| 3 | 53 | ‚úÖ |
| $\vdots$ | $\vdots$ | ‚úÖ |

:::
::: {.column width="20%"}

![](images/two_hours.jpg){fig-align="center"}

:::
::: {.column width="50%"}

<table>
<thead>
<tr>
  <th>$n$</th>
  <th>$f(n)$</th>
  <th align="center">Prime?</th>
</tr>
</thead>
<tbody>
<tr>
  <td>38</td>
  <td>1523</td>
  <td align="center">‚úÖ</td>
</tr>
<tr>
  <td colspan="3">*I can stop checking now right?*</td>
</tr>
<tr>
  <td>39</td>
  <td>1601</td>
  <td align="center">‚úÖ</td>
</tr>
<tr>
  <td colspan="3">*Surely I've checked enough terms?*</td>
</tr>
<tr>
  <td>40</td>
  <td>1681</td>
  <td align="center">‚ùå $1681 = 41 \times 41$ üíÄ</td>
</tr>
<tr>
  <td colspan="3">*Maybe that's the only exception?*</td>
</tr>
<tr>
  <td>41</td>
  <td>1763</td>
  <td align="center">‚ùå $1763 = 41 \times 43$ üíÄ</td>
</tr>
<tr>
  <td colspan="3">*Maybe we can get **composites** $n > 41$?*</td>
</tr>
<tr>
  <td>42</td>
  <td>1847</td>
  <td align="center">‚úÖ üíÄüíÄüíÄ *USELESS!*</td>
</tr>
</tbody>
</table>

:::
::::

## (Non-Engineers') Induction! {.crunch-title .text-85 .crunch-ul .crunch-math .crunch-hr}

* Goal: Prove $p(n)$ ("predicate", evaluates to T/F for given $n \in \mathbb{Z}^{\geq 0}$)
* The core is literally just: If I know
  * <i class='bi bi-1-circle'></i> **Base Case:** [$p$ is true for $n = n_0$]
  * <i class='bi bi-2-circle'></i> **Inductive Step:** [$p$ is true for $n$] $\implies$ [$p$ is true for $n + 1$]
* Then I can conclude $p(n)$ **true for all $n \geq 1$**!

<hr>

* Gauss' Summation Formula: $p(n) = \left[ \sum_{i=0}^{n}i = \frac{n(n+1)}{2} \right]$
* Base Case: $n_0 = 1$:

$$
\sum_{i=0}^{1} = 0 + 1 \overset{?}{=} \frac{(1)(1+1)}{2} \iff 1 \overset{?}{=} \frac{2}{2} \iff 1 \overset{‚úÖ}{=} 1
$$

## Inductive Step: Can I Infer $n + 1$ From $n$? {.smaller .crunch-title .title-11 .crunch-ul}

* **Assume** $p(n)$, that is, $\displaystyle\sum_{i=0}^{n}i = \frac{n(n+1)}{2}$.
* **Goal:** Derive $p(n + 1)$, that is, $\displaystyle\sum_{i=0}^{n+1}i = \frac{(n+1)(n+2)}{2}$...
* Start with LHS term, $\sum_{i=0}^{n+1}i$:

$$
\begin{align*}
\boxed{\sum_{i=0}^{n+1}i} &= \underbrace{0 + 1 + 2 + \cdots + n}_{\sum_{i=0}^{n}i} + (n+1) = \underbrace{\sum_{i=0}^{n}i}_{\mathclap{\text{LHS of }p(n)}} + (n+1) \\
&= \frac{n(n+1)}{2} + (n + 1) = \frac{n^2 + n}{2} + \frac{2(n+1)}{2} \\
&= \frac{n^2 + 3n + 2}{2} = \boxed{\frac{(n+1)(n+2)}{2}} \; ~ ‚úÖ
\end{align*}
$$

## (Algorithmic/Data-Structural Proofs Almost Always Inductive!) {.crunch-title .text-85 .math-80}

* **"Direct" proof**, in this case, is doable but requires stuff like...
* <i class='bi bi-1-circle'></i> Break into [Case 1: $n$ even] and [Case 2: $n$ odd]
* <i class='bi bi-2-circle'></i> In case 2

  $$
  \sum_{i=0}^{n}i = 1 + 2 + \cdots + \left( \left\lceil \frac{n}{2} \right\rceil - 1\right) + \left\lceil \frac{n}{2} \right\rceil + \left( \left\lceil \frac{n}{2} \right\rceil + 1\right) + \cdots + (n-1) + n
  $$

* <i class='bi bi-3-circle'></i> Need to show (...with induction?) $\left\lceil \frac{n}{2} \right\rceil = \begin{cases}\frac{n}{2} &\text{if }n\text{ even} \\ \frac{n+1}{2} &\text{if }n\text{ odd}\end{cases}$
* And so on...

# Core Data Structure: `LinkedList` {data-stack-name="LinkedList"}

## Looking Under the Hood of a Data Structure {.crunch-title .title-08 .inline-90 .text-95}

* Last week we saw the **math** for why we can "abstract away from" the details of how a particular language works
* We want to understand these structures **independently** of the specifics of their implementation in Python (for now)
* So, let's construct our own **simplified versions** of the basic structures, and use these simplified versions to get a sense for their **efficiency**
  * (The "true" Python versions may be **hyper-optimized** but, as we'll see, there are **fundamental constraints** on runtime, assuming $P \neq NP$)

## Tuples

```{python}
#| label: mytuple-definition
class MyTuple:
  def __init__(self, thing1, thing2):
    self.thing1 = thing1
    self.thing2 = thing2

  def __repr__(self):
    return f"({self.thing1}, {self.thing2})"

  def __str__(self):
    return self.__repr__()

t1 = MyTuple('a','b')
t2 = MyTuple(111, 222)
print(t1)
print(t2)
```

## Lists {.crunch-title .smaller}

::: columns
::: {.column width="50%"}

The list itself just **points** to a root item:

```{python}
#| label: mylist-definition
class MyList:
  def __init__(self):
    self.root = None

  def append(self, new_item):
    if self.root is None:
      self.root = MyListItem(new_item)
    else:
      self.root.append(new_item)

  def __repr__(self):
    return self.root.__repr__()
```

:::
::: {.column width="50%"}

An item has contents, pointer to next item:

```{python}
#| label: mylistitem-definition
class MyListItem:
  def __init__(self, content):
    self.content = content
    self.next = None

  def append(self, new_item):
    if self.next is None:
      self.next = MyListItem(new_item)
    else:
      self.next.append(new_item)

  def __repr__(self):
    my_content = self.content
    return my_content if self.next is None else f"{my_content}, {self.next.__repr__()}"
```

:::
:::

```{python}
#| label: mylist-append
users = MyList()
users.append('Jeff')
users.append('Alma')
users.append('Bo')
print(users)
```

## So, How Many "Steps" Are Required...

* To retrieve the **first** element in a `MyTuple`?
* To retrieve the **last** element in a `MyTuple`?
* To retrieve the **first** element in a `MyList`?
* To retrieve the **last** element in a `MyList`?

## How Many Steps? {.smaller}

::: columns
::: {.column width="50%"}

With a `MyTuple`:

```{python}
#| label: steps-thing1
t1.thing1
```

$\implies$ 1 step

```{python}
#| label: steps-thing2
t1.thing2
```

$\implies$ 1 step

:::
::: {.column width="50%"}

With a `MyList`:

```{python}
#| label: mylist-root-content
print(users.root.content)
```

$\implies$ 1 step

```{python}
#| label: mylist-last
current_node = users.root
while current_node.next is not None:
  current_node = current_node.next
print(current_node.content)
```

$\implies$ (3 steps) 

...But why 3? How many steps if the list contained 5 elements? $N$ elements?

:::
:::

## Visualizing `LinkedList`s {.smaller .crunch-title .crunch-col-output .crunch-details}

```{python}
#| label: graphviz-setup-linkedlist
#| echo: false
import sys
# Important! Allows us to use HW2 classes within these slides...
sys.path.append('../../dsan5500-local/hw2/')
from IPython.display import display, HTML
import graphviz as gv # for visualizing a tree using Digraph
from graphviz import Digraph, nohtml
from hw2 import EmptyNode

def visualize_ll(ll):
  dot = Digraph(
      graph_attr={'rankdir': 'LR'},
        node_attr={'shape': 'record', 'height': '.1'}
    )
  prev_node_name = None
  node_pointer = ll.root
  while type(node_pointer) != EmptyNode:
    # New node
    cur_content = node_pointer.content
    cur_name = cur_content.item_name
    dot.node(name=cur_name, label=nohtml('{<f0> '+str(cur_name)+'|<f1>}'))
    # And edge from prev to cur, if not None
    if prev_node_name is not None:
      edge_from = f'{prev_node_name}:f1'
      dot.edge(edge_from, cur_name)
    # Now we can update prev_node_name
    prev_node_name = cur_name
    node_pointer = node_pointer.next
  # Now we've reached the end, so point to an EmptyNode
  final_name = "None"
  dot.node(name=final_name, label=str(final_name), penwidth='0')
  edge_from = f'{prev_node_name}:f1'
  dot.edge(edge_from, final_name)
  display(dot)

def visualize(tree):
    none_counter = 0
    dot = Digraph(
        node_attr={'shape': 'record', 'height': '.1'}
    )
    #dot.engine = 'sfdp'
    node_info_list = []
    if tree.root is not None:
      node_info_list.append({'node':tree.root, 'parent_name': None, 'dir': None})
    while len(node_info_list) > 0:
      cur_node_info = node_info_list.pop()
      cur_node = cur_node_info['node']
      if cur_node is None:
        cur_name = f"None_{none_counter}"
        none_counter = none_counter + 1
        cur_label = "None"
        cur_parent_name = cur_node_info['parent_name']
        cur_dir = cur_node_info['dir']
        dot.node(name=cur_name, label="None", penwidth='0')
        if cur_parent_name is not None:
          # Nudge x coord based on parent
          which_port = 'f0'
          if cur_dir == 'R':
            which_port = 'f2'
          edge_from = f'{cur_parent_name}:{which_port}'
          edge_to = f'{cur_name}:f1'
          dot.edge(edge_from, edge_to, label=cur_dir)
      else:
        cur_name = cur_node.content.item_name
        cur_parent_name = cur_node_info['parent_name']
        cur_dir = cur_node_info['dir']
        dot.node(name=cur_name, label=nohtml(f'<f0>|<f1> {cur_name}|<f2>'))
        if cur_parent_name is not None:
          # Nudge x coord based on parent
          which_port = 'f0'
          if cur_dir == 'R':
            which_port = 'f2'
          edge_from = f'{cur_parent_name}:{which_port}'
          edge_to = f'{cur_name}:f1'
          dot.edge(edge_from, edge_to, label=cur_dir)
        if cur_node.right is not None:
          node_info_list.append({'node': cur_node.right, 'parent_name': cur_name, 'dir': 'R'})
        else:
          # Add the None ending
          node_info_list.append({'node': None, 'parent_name': cur_name, 'dir': 'R'})
        if cur_node.left is not None:
          node_info_list.append({'node': cur_node.left, 'parent_name': cur_name, 'dir': 'L'})
        else:
          # Add the None ending
          node_info_list.append({'node': None, 'parent_name': cur_name, 'dir': 'L'})
    display(dot)
```

::: {.vcenter}

```{python}
#| label: viz-linkedlist
#| fig-align: center
from hw2 import LinkedList, InventoryItem
ll = LinkedList()
item1 = InventoryItem('Mango', 50)
ll.append(item1)
item2 = InventoryItem('Pickle', 60)
ll.append(item2)
item3 = InventoryItem('Artichoke', 55)
ll.append(item3)
item5 = InventoryItem('Banana', 123)
ll.append(item5)
item6 = InventoryItem('Aardvark', 11)
ll.append(item6)
HTML(visualize_ll(ll))
```

:::

# Onwards and Upwards: Fancier Algorithms {data-stack-name="FancyLinkedList"}

## LinkedList: Foundation for Most(?) Data Structures! {.smaller .crunch-title .title-09 .crunch-quarto-layout-panel .crunch-img .crunch-figures .cols-va}

::: {layout="[1,3]" layout-valign="center"}

![](images/bored_pooh.jpeg){fig-align="left" width="210"}

::: {#bored-pooh}

::: {.columns}
::: {.column width="50%"}

``` {.python}
class LinkedList(BaseModel):
  root: LinkedListNode | None
```

:::
::: {.column width="50%"}

```python
class LinkedListNode(BaseModel):
  content: object
  next: LinkedListNode | None
```

:::
:::

:::
:::

::: {layout="[1,3]" layout-valign="center"}

![](images/fancy_pooh_single.jpeg){fig-align="left" width="210"}

::: {#fancy-pooh}

::: {.columns}
::: {.column width="50%"}

```python
class BinaryTree(BaseModel):
  root: BinaryTreeNode | None
```

:::
::: {.column width="50%"}

```python
class BinaryTreeNode(BaseModel):
  content: object
  left: BinaryTreeNode | None
  right: BinaryTreeNode | None
```

:::
:::

:::
:::

::: {layout="[1,3]" layout-valign="center"}

![](images/fanciest_pooh.jpeg){fig-align="left" width="210"}

::: {#fanciest-pooh}

::: {.columns}
::: {.column width="50%"}

```python
class QuadTree(BaseModel):
  root: QuadTreeNode | None
```

:::
::: {.column width="50%"}

```python
class QuadTreeNode:
  content: object
  nw: QuadTreeNode | None
  ne: QuadTreeNode | None
  sw: QuadTreeNode | None
  se: QuadTreeNode | None
```

:::
:::

:::
:::

## Visualizing `BinarySearchTree` {.smaller .crunch-title .cols-va}

```{python}
#| output-location: column
#| fig-align: center
from hw2 import BinarySearchTree
bst = BinarySearchTree()
item1 = InventoryItem('Mango', 50)
bst.add(item1)
item2 = InventoryItem('Pickle', 60)
bst.add(item2)
item3 = InventoryItem('Artichoke', 55)
bst.add(item3)
item5 = InventoryItem('Banana', 123)
bst.add(item5)
item6 = InventoryItem('Aardvark', 11)
bst.add(item6)
HTML(visualize(bst))
```

## So Then... Why Is This a Whole Class? {.smaller .crunch-title .title-12}

* The **core structures** are identical, but we can optimize **different goals** (efficient insertion, sorting, retrieval, deletion, ...) by changing the **invariants** maintained by the algorithms **internal to** our structure
* Crucial [Insertion-Sort]{.alg} invariant: $\textsf{Sorted}(1,i)$ true when we move to entry $i + 1$ (`key`)
* Crucial **HW2**(!) invariant: $\textsf{Up-To-Date-Favorite}(1,i-1)$ true when entry $i + 1$ (next result in dataset) arrives
* $\implies$ Efficiency of obtaining favorite style **guaranteed to be constant-time**, $\overline{O}(1)$!
* Otherwise, would be $\overline{O}(n) > \overline{O}(1)$ (linear approach) or at best $\overline{O}(\log_2(n)) > \overline{O}(1)$ (divide-and-conquer)

